
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¤– HydroDynamic Trading Bot - Ù†Ø³Ø®Ù‡ 9.1 (FIXED & OPTIMIZED)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… Fixed: Stop Loss calculations (minimum 15 pips)
// âœ… Fixed: Peak Detection logic (correct price comparison)
// âœ… Fixed: Fractal Dimension optimization (faster calculations)
// âœ… Fixed: Toxicity Guard logic (works when disabled)
// âœ… Fixed: TIP Trigger logic (direct execution when disabled)
// âœ… Fixed: Entry logic for both Buy and Sell sides
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using cAlgo.API;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;

namespace cAlgo.Robots
{
    [Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.None)]
    public class HydroDynamicTradingBot : Robot
    {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENUMS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        public enum TrendMode
        {
            Slope,    // Ø´ÛŒØ¨ ÛŒÚ© SuperSmoother
            Cross     // ØªÙ‚Ø§Ø·Ø¹ Ø¯Ùˆ SuperSmoother
        }
        
        public enum LogLevel
        {
            DEBUG = 0,
            INFO = 1,
            WARNING = 2,
            ERROR = 3,
            NONE = 4
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Ú¯Ø±ÙˆÙ‡ 1: ØªÙ†Ø¸ÛŒÙ…Ø§Øª Trend
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        [Parameter("Trend Mode", DefaultValue = TrendMode.Slope, Group = "Trend")]
        public TrendMode TrendDetectionMode { get; set; }
        
        [Parameter("Fast Smooth Length", DefaultValue = 10, MinValue = 5, MaxValue = 50, Group = "Trend")]
        public int FastSmoothLength { get; set; }
        
        [Parameter("Slow Smooth Length", DefaultValue = 20, MinValue = 10, MaxValue = 100, Group = "Trend")]
        public int SlowSmoothLength { get; set; }
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Ú¯Ø±ÙˆÙ‡ 2: ØªÙ†Ø¸ÛŒÙ…Ø§Øª Fractal
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        [Parameter("Fractal Period (N)", DefaultValue = 2, MinValue = 1, MaxValue = 5, Group = "Fractal")]
        public int FractalPeriod { get; set; }
        
        [Parameter("Window Size", DefaultValue = 50, MinValue = 30, Group = "Fractal")]
        public int WindowSize { get; set; }
        
        [Parameter("Max K", DefaultValue = 8, MinValue = 2, MaxValue = 20, Group = "Fractal")]
        public int MaxK { get; set; }
        
        [Parameter("Chaos Threshold", DefaultValue = 1.65, MinValue = 1.0, MaxValue = 2.0, Group = "Fractal")]
        public double ChaosThreshold { get; set; }
        
        [Parameter("P-Zero Lookback", DefaultValue = 20, MinValue = 10, MaxValue = 100, Group = "Fractal")]
        public int PZeroLookback { get; set; }
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Ú¯Ø±ÙˆÙ‡ 3: ØªÙ†Ø¸ÛŒÙ…Ø§Øª TIP (Trigger)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        [Parameter("Enable Trigger (TIP)", DefaultValue = true, Group = "TIP")]
        public bool EnableTrigger { get; set; }
        
        [Parameter("TIP Z-Score Threshold", DefaultValue = 2.0, MinValue = 1.0, MaxValue = 3.5, Group = "TIP")]
        public double TIPZScoreThreshold { get; set; }
        
        [Parameter("TIP Lookback Bars", DefaultValue = 5, MinValue = 3, MaxValue = 10, Group = "TIP")]
        public int TIPLookbackBars { get; set; }
        
        [Parameter("TIP History Size", DefaultValue = 100, MinValue = 50, MaxValue = 200, Group = "TIP")]
        public int TIPHistorySize { get; set; }
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Ú¯Ø±ÙˆÙ‡ 4: ØªÙ†Ø¸ÛŒÙ…Ø§Øª Toxicity
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        [Parameter("Enable Toxicity Guard", DefaultValue = true, Group = "Toxicity")]
        public bool EnableToxicityGuard { get; set; }
        
        [Parameter("Spread History", DefaultValue = 50, MinValue = 30, MaxValue = 100, Group = "Toxicity")]
        public int SpreadHistorySize { get; set; }
        
        [Parameter("Toxicity Threshold", DefaultValue = 2.5, MinValue = 1.5, MaxValue = 5.0, Group = "Toxicity")]
        public double ToxicityThreshold { get; set; }
        
        [Parameter("Warmup Minutes", DefaultValue = 60, MinValue = 30, MaxValue = 180, Group = "Toxicity")]
        public int WarmupMinutes { get; set; }
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Ú¯Ø±ÙˆÙ‡ 5: Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÛŒØ³Ú©
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        [Parameter("Risk Percent", DefaultValue = 1.0, MinValue = 0.1, MaxValue = 5.0, Group = "Risk")]
        public double RiskPercent { get; set; }
        
        [Parameter("Max Positions", DefaultValue = 1, MinValue = 1, MaxValue = 5, Group = "Risk")]
        public int MaxPositions { get; set; }
        
        [Parameter("Min Stop Loss Pips", DefaultValue = 15, MinValue = 5, MaxValue = 50, Group = "Risk")]
        public double MinStopLossPips { get; set; }
        
        [Parameter("ATR Period", DefaultValue = 14, MinValue = 5, MaxValue = 50, Group = "Risk")]
        public int ATRPeriod { get; set; }
        
        [Parameter("Use Dynamic SL", DefaultValue = true, Group = "Risk")]
        public bool UseDynamicStopLoss { get; set; }
        
        [Parameter("ATR Multiplier", DefaultValue = 2.5, MinValue = 1.0, MaxValue = 5.0, Group = "Risk")]
        public double ATRMultiplier { get; set; }
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Ú¯Ø±ÙˆÙ‡ 6: Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø®Ø±ÙˆØ¬
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        [Parameter("TP1 Close %", DefaultValue = 50, MinValue = 0, MaxValue = 100, Group = "Exit")]
        public double TP1Percent { get; set; }
        
        [Parameter("Ballistic Multiplier", DefaultValue = 1.618, MinValue = 1.0, MaxValue = 3.0, Group = "Exit")]
        public double BallisticMultiplier { get; set; }
        
        [Parameter("Trailing ATR x", DefaultValue = 1.5, MinValue = 0.5, MaxValue = 3.0, Group = "Exit")]
        public double TrailingATRMultiple { get; set; }
        
        [Parameter("Enable Time Stops", DefaultValue = true, Group = "Exit")]
        public bool EnableTimeStops { get; set; }
        
        [Parameter("Time Stop 1", DefaultValue = 30, MinValue = 10, MaxValue = 100, Group = "Exit")]
        public int TimeStop1Bars { get; set; }
        
        [Parameter("Time Stop 2", DefaultValue = 50, MinValue = 20, MaxValue = 150, Group = "Exit")]
        public int TimeStop2Bars { get; set; }
        
        [Parameter("Trend Reversal Exit", DefaultValue = true, Group = "Exit")]
        public bool EnableTrendReversalExit { get; set; }
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Ú¯Ø±ÙˆÙ‡ 7: Ú©Ù†ØªØ±Ù„ Ùˆ Ù†Ù…Ø§ÛŒØ´
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        [Parameter("Trading Enabled", DefaultValue = false, Group = "Control")]
        public bool TradingEnabled { get; set; }
        
        [Parameter("Magic Number", DefaultValue = 123456, Group = "Control")]
        public int MagicNumber { get; set; }
        
        [Parameter("Log Level", DefaultValue = LogLevel.INFO, Group = "Display")]
        public LogLevel LoggingLevel { get; set; }
        
        [Parameter("Show Stats", DefaultValue = true, Group = "Display")]
        public bool ShowPerformanceStats { get; set; }
        
        [Parameter("Show Dashboard", DefaultValue = true, Group = "Display")]
        public bool ShowDashboard { get; set; }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Ø³Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±
        private IndicatorDataSeries _fastSmooth;
        private IndicatorDataSeries _slowSmooth;
        private IndicatorDataSeries _trendState;
        private IndicatorDataSeries _fractalDimension;
        
        // Ø¶Ø±Ø§ÛŒØ¨ SuperSmoother
        private double _c1Fast, _c2Fast, _c3Fast;
        private double _c1Slow, _c2Slow, _c3Slow;
        
        // Ø¨Ø§ÙØ±Ù‡Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ø§ØªÛŒ - OPTIMIZED
        private Queue<double> _fdBuffer;
        private int _fdBufferSize;
        
        // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ P-Zero Ø¯ÙˆÚ¯Ø§Ù†Ù‡
        private double _pZeroBuy;
        private double _pZeroSell;
        
        // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø´Ú©Ø§Ø±Ú†ÛŒ Ù‚Ù„Ù‡ ÙØ±Ú©ØªØ§Ù„ÛŒ
        private bool _chaosActive;
        private double _chaosStartPrice;
        private int _chaosStartBar;
        private bool _fractalPeakDetected;
        private double _peakFD;
        private double _peakPrice;
        private int _peakBar;
        
        // Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø±
        private TradeType? _pendingSignal;
        private bool _tradeTaken;
        
        // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ TIP
        private int _buyTicks;
        private int _sellTicks;
        private double _lastAsk;
        private double _currentTIP;
        private Queue<double> _tipHistory;
        private double _normalizedTIP;
        
        // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Toxicity
        private List<double> _minuteSpreads;
        private Queue<double> _rollingBaseline;
        private double _baselineSpread;
        private double _toxicityScore;
        private bool _marketSafe;
        private int _lastProcessedMinute;
        private bool _isWarmedUp;
        private List<double> _xValues;
        private List<double> _yValues;
        // Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ø§Øª
        private Dictionary<int, TradeContext> _activeTrades;
        private readonly object _tradesLock = new object();
        
        // Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ± ATR
        private AverageTrueRange _atr;
        
        // Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ú©Ù…Ú©ÛŒ
        private Logger _logger;
        private PerformanceMonitor _perfMonitor;
        
        // Dashboard
        private Border _mainBorder;
        private StackPanel _contentPanel;
        private TextBlock _valGuard;
        private TextBlock _valTrend;
        private TextBlock _valState;
        private TextBlock _valZeroBuy;
        private TextBlock _valZeroSell;
        private TextBlock _valTrigger;
        private TextBlock _valTrades;
        
        private readonly Color _colTitle = Color.Gold;
        private readonly Color _colPositive = Color.Lime;
        private readonly Color _colNegative = Color.Red;
        private readonly Color _colNeutral = Color.WhiteSmoke;
        private readonly Color _colWarning = Color.Orange;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS: Logger
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private class Logger
        {
            private readonly Robot _robot;
            private readonly LogLevel _level;
            private readonly StringBuilder _buffer;
            private int _logCount;
            
            public Logger(Robot robot, LogLevel level)
            {
                _robot = robot;
                _level = level;
                _buffer = new StringBuilder();
                _logCount = 0;
            }
            
            public void Debug(string message)
            {
                if (_level <= LogLevel.DEBUG)
                    Log("DEBUG", message, "ğŸ”");
            }
            
            public void Info(string message)
            {
                if (_level <= LogLevel.INFO)
                    Log("INFO", message, "â„¹ï¸");
            }
            
            public void Warning(string message)
            {
                if (_level <= LogLevel.WARNING)
                    Log("WARN", message, "âš ï¸");
            }
            
            public void Error(string message, Exception ex = null)
            {
                if (_level <= LogLevel.ERROR)
                {
                    string full = message;
                    if (ex != null)
                        full += $"\nException: {ex.Message}";
                    Log("ERROR", full, "âŒ");
                }
            }
            
            private void Log(string level, string message, string icon)
            {
                _logCount++;
                string time = _robot.Server.Time.ToString("HH:mm:ss");
                string formatted = $"[{time}] {icon} {level}: {message}";
                _robot.Print(formatted);
                _buffer.AppendLine(formatted);
                
                if (_logCount % 1000 == 0)
                    _buffer.Clear();
            }
            
            public string GetSummary()
            {
                return $"Total logs: {_logCount}";
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS: Performance Monitor
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private class PerformanceMonitor
        {
            private DateTime _startTime;
            private int _totalTrades;
            private int _winningTrades;
            private int _losingTrades;
            private double _totalProfit;
            private double _totalLoss;
            private double _largestWin;
            private double _largestLoss;
            
            public void Start()
            {
                _startTime = DateTime.UtcNow;
                _totalTrades = 0;
                _winningTrades = 0;
                _losingTrades = 0;
                _totalProfit = 0;
                _totalLoss = 0;
                _largestWin = 0;
                _largestLoss = 0;
            }
            
            public void RecordTrade(double pnl)
            {
                _totalTrades++;
                
                if (pnl > 0)
                {
                    _winningTrades++;
                    _totalProfit += pnl;
                    if (pnl > _largestWin)
                        _largestWin = pnl;
                }
                else
                {
                    _losingTrades++;
                    _totalLoss += Math.Abs(pnl);
                    if (Math.Abs(pnl) > _largestLoss)
                        _largestLoss = Math.Abs(pnl);
                }
            }
            
            public string GetReport()
            {
                var sb = new StringBuilder();
                var runtime = DateTime.UtcNow - _startTime;
                
                sb.AppendLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                sb.AppendLine("ğŸ“Š PERFORMANCE SUMMARY");
                sb.AppendLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                sb.AppendLine($"Runtime: {runtime.Days}d {runtime.Hours}h {runtime.Minutes}m");
                sb.AppendLine($"Total Trades: {_totalTrades}");
                sb.AppendLine($"Winning: {_winningTrades} ({(_totalTrades > 0 ? (double)_winningTrades / _totalTrades * 100 : 0):F1}%)");
                sb.AppendLine($"Losing: {_losingTrades} ({(_totalTrades > 0 ? (double)_losingTrades / _totalTrades * 100 : 0):F1}%)");
                sb.AppendLine($"Total Profit: ${_totalProfit:F2}");
                sb.AppendLine($"Total Loss: ${_totalLoss:F2}");
                sb.AppendLine($"Net P&L: ${(_totalProfit - _totalLoss):F2}");
                sb.AppendLine($"Largest Win: ${_largestWin:F2}");
                sb.AppendLine($"Largest Loss: ${_largestLoss:F2}");
                
                if (_totalTrades > 0)
                {
                    double avgWin = _winningTrades > 0 ? _totalProfit / _winningTrades : 0;
                    double avgLoss = _losingTrades > 0 ? _totalLoss / _losingTrades : 0;
                    double profitFactor = _totalLoss > 0 ? _totalProfit / _totalLoss : 0;
                    
                    sb.AppendLine($"Avg Win: ${avgWin:F2}");
                    sb.AppendLine($"Avg Loss: ${avgLoss:F2}");
                    sb.AppendLine($"Profit Factor: {profitFactor:F2}");
                }
                
                sb.AppendLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                return sb.ToString();
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS: Trade Context
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private class TradeContext
        {
            public int PositionId { get; set; }
            public double EntryPrice { get; set; }
            public double PZero { get; set; }
            public double Stretch { get; set; }
            public double TP1 { get; set; }
            public double TP2 { get; set; }
            public bool TP1Hit { get; set; }
            public bool TP2Hit { get; set; }
            public bool TrailingActive { get; set; }
            public int EntryBarIndex { get; set; }
            public int EntryTrendState { get; set; }
            public TradeType Direction { get; set; }
            public DateTime EntryTime { get; set; }
            
            public override string ToString()
            {
                return $"Pos {PositionId}: {Direction} @ {EntryPrice:F5}, P_zero={PZero:F5}";
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ON START
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        protected override void OnStart()
        {
            try
            {
                // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ú©Ù…Ú©ÛŒ
                _logger = new Logger(this, LoggingLevel);
                _perfMonitor = new PerformanceMonitor();
                _perfMonitor.Start();
                
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info(" HydroDynamic Bot v9.1 - FIXED");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info($" Symbol: {SymbolName}");
                _logger.Info($" Timeframe: {TimeFrame}");
                _logger.Info($" Trend Mode: {TrendDetectionMode}");
                _logger.Info($" Trading: {(TradingEnabled ? "ON âœ…" : "OFF âš ï¸")}");
                _logger.Info($" Trigger: {(EnableTrigger ? "ON" : "OFF")}");
                _logger.Info($" Toxicity Guard: {(EnableToxicityGuard ? "ON" : "OFF")}");
                _logger.Info($" Min SL: {MinStopLossPips} pips");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                // Ø§ÛŒØ¬Ø§Ø¯ Ø³Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡
                _fastSmooth = CreateDataSeries();
                _slowSmooth = CreateDataSeries();
                _trendState = CreateDataSeries();
                _fractalDimension = CreateDataSeries();
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¶Ø±Ø§ÛŒØ¨ SuperSmoother (Fast)
                CalculateSuperSmootherCoefficients(FastSmoothLength, out _c1Fast, out _c2Fast, out _c3Fast);
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¶Ø±Ø§ÛŒØ¨ SuperSmoother (Slow) - ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Ø­Ø§Ù„Øª Cross
                if (TrendDetectionMode == TrendMode.Cross)
                {
                    CalculateSuperSmootherCoefficients(SlowSmoothLength, out _c1Slow, out _c2Slow, out _c3Slow);
                }
                
                // Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ù…ØªØºÛŒØ±Ù‡Ø§
                _fdBufferSize = (FractalPeriod * 2) + 1;
                _fdBuffer = new Queue<double>(_fdBufferSize);
                
                // P-Zero Ø¯ÙˆÚ¯Ø§Ù†Ù‡
                _pZeroBuy = 0;
                _pZeroSell = 0;
                
                // Ø´Ú©Ø§Ø±Ú†ÛŒ Ù‚Ù„Ù‡
                _chaosActive = false;
                _chaosStartPrice = 0;
                _chaosStartBar = -1;
                _fractalPeakDetected = false;
                _peakFD = 0;
                _peakPrice = 0;
                _peakBar = -1;
                
                // Ø³ÛŒÚ¯Ù†Ø§Ù„
                _pendingSignal = null;
                _tradeTaken = false;
                
                // TIP
                _buyTicks = 0;
                _sellTicks = 0;
                _lastAsk = Symbol.Ask;
                _currentTIP = 0;
                _normalizedTIP = 0;
                _tipHistory = new Queue<double>();
                
                // Toxicity - FIXED: Ø§Ú¯Ø± Ø®Ø§Ù…ÙˆØ´ Ø¨Ø§Ø´Ø¯ØŒ Ù…Ø¬Ø§Ø² Ø§Ø³Øª
                _minuteSpreads = new List<double>();
                _rollingBaseline = new Queue<double>();
                _baselineSpread = 0;
                _toxicityScore = 0;
                _marketSafe = !EnableToxicityGuard; // âœ… Ø§Ú¯Ø± Ø®Ø§Ù…ÙˆØ´ Ø¨Ø§Ø´Ø¯ØŒ Ù‡Ù…ÛŒØ´Ù‡ safe
                _lastProcessedMinute = Server.Time.Minute;
                _isWarmedUp = !EnableToxicityGuard; // âœ… Ø§Ú¯Ø± Ø®Ø§Ù…ÙˆØ´ Ø¨Ø§Ø´Ø¯ØŒ Ù‡Ù…ÛŒØ´Ù‡ warmed up
                
                // Ù…Ø¹Ø§Ù…Ù„Ø§Øª
                _activeTrades = new Dictionary<int, TradeContext>();
                _atr = Indicators.AverageTrueRange(ATRPeriod, MovingAverageType.Simple);
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ
                int lookback = Math.Min(300, Bars.Count); // Ú©Ø§Ù‡Ø´ Ø§Ø² 500 Ø¨Ù‡ 300
                int startIndex = Math.Max(0, Bars.Count - lookback);
                
                _logger.Info($"â³ Warming up indicators (Last {lookback} bars)...");
                _xValues = new List<double>(MaxK);
                _yValues = new List<double>(MaxK);

                for (int i = startIndex; i < Bars.Count; i++)
                {
                    CalculateTrend(i);
                    CalculateFD(i);
                    UpdateDualPZero(i);
                }
                
                _logger.Info($"âœ… Ready - {Bars.Count} bars processed");
                
                // Ø«Ø¨Øª events
                Positions.Closed += OnPositionClosed;
                
                // Dashboard
                if (ShowDashboard)
                {
                    InitializeDashboard();
                }
                
                _logger.Info("ğŸš€ Bot started successfully!");
            }
            catch (Exception ex)
            {
                Print($"âŒ CRITICAL: {ex.Message}");
                Stop();
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Helper: Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¶Ø±Ø§ÛŒØ¨ SuperSmoother
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void CalculateSuperSmootherCoefficients(int length, out double c1, out double c2, out double c3)
        {
            double arg = 1.414 * Math.PI / length;
            double a1 = Math.Exp(-arg);
            double b1 = 2.0 * a1 * Math.Cos(arg);
            
            c2 = b1;
            c3 = -a1 * a1;
            c1 = (1.0 - c2 - c3) / 2.0;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ON TICK
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        private DateTime _lastDashUpdate;
        protected override void OnTick()
        {
            try
            {
                // Ø´Ù…Ø§Ø±Ø´ Buy/Sell Ticks
                double currentAsk = Symbol.Ask;
                
                if (currentAsk > _lastAsk)
                    _buyTicks++;
                else if (currentAsk < _lastAsk)
                    _sellTicks++;
                
                _lastAsk = currentAsk;
                
                // Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø²
                if (TradingEnabled && _activeTrades.Count > 0)
                {
                    ManagePositions();
                }
                
                // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Toxicity - ÙÙ‚Ø· Ø§Ú¯Ø± ÙØ¹Ø§Ù„ Ø¨Ø§Ø´Ø¯
                if (EnableToxicityGuard)
                {
                    UpdateToxicity();
                }
                
                // Ú†Ú© Ú©Ø±Ø¯Ù† Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± - ÙÙ‚Ø· Ø§Ú¯Ø± TIP ÙØ¹Ø§Ù„ Ø¨Ø§Ø´Ø¯
                if (EnableTrigger && _pendingSignal.HasValue && !_tradeTaken)
                {
                    CheckTriggerExecution();
                }
                
               
        // ğŸ›‘ Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡: Ù„Ú¯â€ŒÚ¯ÛŒØ± Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ (ÙÙ‚Ø· Ù‡Ø± Û± Ø«Ø§Ù†ÛŒÙ‡ Ø¢Ù¾Ø¯ÛŒØª Ø´Ùˆ)
           if (ShowDashboard && (Server.Time - _lastDashUpdate).TotalSeconds >= 1)
        {
            try 
            { 
                UpdateDashboard(); 
                _lastDashUpdate = Server.Time; 
            } 
            catch { }
        }
    }
            catch (Exception ex)
            {
                _logger.Error("Error in OnTick", ex);
            }
 }
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ON BAR
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        protected override void OnBar()
        {
            try
            {
                int index = Bars.Count - 1;
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
                CalculateTrend(index);
                CalculateFD(index);
                UpdateDualPZero(index);
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ TIP - ÙÙ‚Ø· Ø§Ú¯Ø± ÙØ¹Ø§Ù„ Ø¨Ø§Ø´Ø¯
                if (EnableTrigger)
                {
                    CalculateTIP();
                }
                
                // Ø´Ú©Ø§Ø± Ù‚Ù„Ù‡ ÙØ±Ú©ØªØ§Ù„ÛŒ
                DetectFractalPeak(index);
                
                // Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø±Ø§ÛŒØ· ÙˆØ±ÙˆØ¯
                if (TradingEnabled)
                {
                    CheckEntry(index);
                }
                
                // Ø±Ø³Ù… P-Zero
                if (ShowDashboard)
                {
                    DrawPZeroMarkers();
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in OnBar", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CALCULATE TREND - Ù…ÙˆØªÙˆØ± ØªØ´Ø®ÛŒØµ Ø±ÙˆÙ†Ø¯ (Slope ÛŒØ§ Cross)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void CalculateTrend(int index)
        {
            if (index < 2)
            {
                _fastSmooth[index] = Bars.ClosePrices[index];
                _slowSmooth[index] = Bars.ClosePrices[index];
                _trendState[index] = 0;
                return;
            }
            
            try
            {
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Fast SuperSmoother
                double priceAvgFast = (Bars.ClosePrices[index] + Bars.ClosePrices[index - 1]) / 2.0;
                
                _fastSmooth[index] = _c1Fast * priceAvgFast
                                   + _c2Fast * _fastSmooth[index - 1]
                                   + _c3Fast * _fastSmooth[index - 2];
                
                if (TrendDetectionMode == TrendMode.Slope)
                {
                    // Ø­Ø§Ù„Øª Slope: Ù…Ù‚Ø§ÛŒØ³Ù‡ Ù…Ù‚Ø¯Ø§Ø± ÙØ¹Ù„ÛŒ Ø¨Ø§ Ù‚Ø¨Ù„ÛŒ
                    if (_fastSmooth[index] > _fastSmooth[index - 1])
                    {
                        _trendState[index] = 1;  // ØµØ¹ÙˆØ¯ÛŒ
                    }
                    else if (_fastSmooth[index] < _fastSmooth[index - 1])
                    {
                        _trendState[index] = -1;  // Ù†Ø²ÙˆÙ„ÛŒ
                    }
                    else
                    {
                        _trendState[index] = 0;  // Ø®Ù†Ø«ÛŒ
                    }
                }
                else // TrendMode.Cross
                {
                    // Ù…Ø­Ø§Ø³Ø¨Ù‡ Slow SuperSmoother
                    double priceAvgSlow = (Bars.ClosePrices[index] + Bars.ClosePrices[index - 1]) / 2.0;
                    
                    _slowSmooth[index] = _c1Slow * priceAvgSlow
                                       + _c2Slow * _slowSmooth[index - 1]
                                       + _c3Slow * _slowSmooth[index - 2];
                    
                    // Ù…Ù‚Ø§ÛŒØ³Ù‡ Fast Ùˆ Slow
                    if (_fastSmooth[index] > _slowSmooth[index])
                    {
                        _trendState[index] = 1;  // ØµØ¹ÙˆØ¯ÛŒ
                    }
                    else if (_fastSmooth[index] < _slowSmooth[index])
                    {
                        _trendState[index] = -1;  // Ù†Ø²ÙˆÙ„ÛŒ
                    }
                    else
                    {
                        _trendState[index] = 0;  // Ø®Ù†Ø«ÛŒ
                    }
                }
            }
            catch (Exception ex)
            {
                _trendState[index] = 0;
                _logger.Error($"Error in CalculateTrend at {index}", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CALCULATE FD - Ù…Ø­Ø§Ø³Ø¨Ù‡ Fractal Dimension Ø¨Ø§ Ø§Ù„Ú¯ÙˆØ±ÛŒØªÙ… Higuchi (OPTIMIZED)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
       private void CalculateFD(int index)
{
    if (index < WindowSize - 1)
    {
        _fractalDimension[index] = 1.0;
        return;
    }
    
    try
    {
        // ğŸ›‘ Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡: Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…Ø¬Ø¯Ø¯ Ø§Ø² Ù„ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ú©Ù„Ø§Ø³ (Ø¨Ø¯ÙˆÙ† new Ú©Ø±Ø¯Ù†)
        _xValues.Clear();
        _yValues.Clear();
        
        int startIdx = index - WindowSize + 1;
        
        for (int k = 1; k <= MaxK; k++)
        {
            double lengthSum = 0.0;
            int validSubsets = 0;
            
            for (int m = 0; m < k; m++)
            {
                double Lmk = 0.0;
                int points = (WindowSize - m - 1) / k;
                
                if (points < 1)
                    continue;
                
                for (int i = 1; i <= points; i++)
                {
                    int currIdx = startIdx + m + i * k;
                    int prevIdx = startIdx + m + (i - 1) * k;
                    
                    if (currIdx >= Bars.Count || prevIdx >= Bars.Count)
                        continue;
                    
                    Lmk += Math.Abs(Bars.ClosePrices[currIdx] - Bars.ClosePrices[prevIdx]);
                }
                
                double norm = (WindowSize - 1.0) / (points * k * k);
                lengthSum += Lmk * norm;
                validSubsets++;
            }
            
            if (validSubsets > 0)
            {
                double avgLk = lengthSum / validSubsets;
                if (avgLk > 0 && !double.IsNaN(avgLk) && !double.IsInfinity(avgLk))
                {
                    _xValues.Add(Math.Log(1.0 / k));
                    _yValues.Add(Math.Log(avgLk));
                }
            }
        }
        
        // Linear Regression
        if (_xValues.Count < 2)
        {
            _fractalDimension[index] = 1.0;
            return;
        }
        
        double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        int n = _xValues.Count;
        
        for (int i = 0; i < n; i++)
        {
            sumX += _xValues[i];
            sumY += _yValues[i];
            sumXY += _xValues[i] * _yValues[i];
            sumX2 += _xValues[i] * _xValues[i];
        }
        
        double denom = n * sumX2 - sumX * sumX;
        
        if (Math.Abs(denom) < 1e-10)
        {
            _fractalDimension[index] = 1.0;
            return;
        }
        
        double fd = (n * sumXY - sumX * sumY) / denom;
        _fractalDimension[index] = Math.Max(1.0, Math.Min(2.0, fd));
    }
    catch (Exception ex)
    {
        _fractalDimension[index] = 1.0;
        _logger.Error($"Error in CalculateFD at {index}", ex);
    }
}
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UPDATE DUAL P-ZERO - Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ P-Zero Ø¯ÙˆÚ¯Ø§Ù†Ù‡
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void UpdateDualPZero(int index)
        {
            if (index < 0)
                return;
            
            try
            {
                // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† High (Ø¨Ø±Ø§ÛŒ Buy)
                _pZeroBuy = Bars.HighPrices[index];
                
                int startBuy = Math.Max(0, index - PZeroLookback + 1);
                for (int i = startBuy; i <= index; i++)
                {
                    if (Bars.HighPrices[i] > _pZeroBuy)
                        _pZeroBuy = Bars.HighPrices[i];
                }
                
                // Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Low (Ø¨Ø±Ø§ÛŒ Sell)
                _pZeroSell = Bars.LowPrices[index];
                
                int startSell = Math.Max(0, index - PZeroLookback + 1);
                for (int i = startSell; i <= index; i++)
                {
                    if (Bars.LowPrices[i] < _pZeroSell)
                        _pZeroSell = Bars.LowPrices[i];
                }
            }
            catch (Exception ex)
            {
                _logger.Error($"Error in UpdateDualPZero at {index}", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DETECT FRACTAL PEAK - Ø´Ú©Ø§Ø±Ú†ÛŒ Ù‚Ù„Ù‡ ÙØ±Ú©ØªØ§Ù„ÛŒ (FIXED LOGIC)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void DetectFractalPeak(int index)
        {
            try
            {
                double currentFD = _fractalDimension[index];
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // 1. Ø«Ø¨Øª Ø´Ø±ÙˆØ¹ Ø¢Ø´ÙˆØ¨
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if (!_chaosActive && currentFD >= ChaosThreshold)
                {
                    _chaosActive = true;
                    _chaosStartPrice = Bars.ClosePrices[index];
                    _chaosStartBar = index;
                    _tradeTaken = false;  // Ø±ÛŒØ³Øª Ù¾Ø±Ú†Ù… Ù…Ø¹Ø§Ù…Ù„Ù‡
                    
                    _logger.Info($"ğŸŒ€ CHAOS STARTED - Bar: {index}, Price: {_chaosStartPrice:F5}, FD: {currentFD:F3}");
                }
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // 2. Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Ø¨Ø§ÙØ± FD
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                _fdBuffer.Enqueue(currentFD);
                
                if (_fdBuffer.Count > _fdBufferSize)
                    _fdBuffer.Dequeue();
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // 3. Ú†Ú© Ú©Ø±Ø¯Ù† Ø´Ø±Ø· ÙˆÛŒÙ„ÛŒØ§Ù…Ø² (Williams Fractal)
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if (_fdBuffer.Count == _fdBufferSize)
                {
                    var fdArray = _fdBuffer.ToArray();
                    int middleIndex = FractalPeriod;
                    double middleValue = fdArray[middleIndex];
                    
                    // Ú†Ú© Ú©Ø±Ø¯Ù†: Ø¢ÛŒØ§ Ù…Ù‚Ø¯Ø§Ø± ÙˆØ³Ø· Ø§Ø² Ù‡Ù…Ù‡ Ø¨Ø²Ø±Ú¯ØªØ± Ø§Ø³ØªØŸ
                    bool isPeak = true;
                    
                    // Ú†Ú© Ú©Ø±Ø¯Ù† Ø³Ù…Øª Ú†Ù¾
                    for (int i = 0; i < middleIndex; i++)
                    {
                        if (fdArray[i] >= middleValue)
                        {
                            isPeak = false;
                            break;
                        }
                    }
                    
                    // Ú†Ú© Ú©Ø±Ø¯Ù† Ø³Ù…Øª Ø±Ø§Ø³Øª
                    if (isPeak)
                    {
                        for (int i = middleIndex + 1; i < _fdBufferSize; i++)
                        {
                            if (fdArray[i] >= middleValue)
                            {
                                isPeak = false;
                                break;
                            }
                        }
                    }
                    
                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    // 4. Ù‚Ù„Ù‡ Ù¾ÛŒØ¯Ø§ Ø´Ø¯ØŸ - FIXED: Ø°Ø®ÛŒØ±Ù‡ Ù‚ÛŒÙ…Øª Ø¯Ø± Ù„Ø­Ø¸Ù‡ Ù‚Ù„Ù‡
                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    if (isPeak && _chaosActive)
                    {
                        // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø§Ø± Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ Ù‚Ù„Ù‡ (FractalPeriod Ø¨Ø§Ø± Ù‚Ø¨Ù„)
                        int peakBarIndex = index - FractalPeriod;
                        
                        // Ú†Ú© Ú©Ø±Ø¯Ù†: Ø¢ÛŒØ§ Ø§ÛŒÙ† Ù‚Ù„Ù‡ Ø¨Ø¹Ø¯ Ø§Ø² Ø´Ø±ÙˆØ¹ Ø¢Ø´ÙˆØ¨ Ø§Ø³ØªØŸ
                        if (peakBarIndex >= _chaosStartBar)
                        {
                            // Ú†Ú© Ú©Ø±Ø¯Ù†: Ø¢ÛŒØ§ Ù…Ù‚Ø¯Ø§Ø± Ù‚Ù„Ù‡ Ø¨Ø§Ù„Ø§ÛŒ Ø®Ø· Ù‚Ø±Ù…Ø² Ø§Ø³ØªØŸ
                            if (middleValue >= ChaosThreshold)
                            {
                                _fractalPeakDetected = true;
                                _peakFD = middleValue;
                                
                                // âœ… FIXED: Ø°Ø®ÛŒØ±Ù‡ Ù‚ÛŒÙ…Øª Ø¯Ø± Ù„Ø­Ø¸Ù‡ Ù‚Ù„Ù‡ØŒ Ù†Ù‡ Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
                                _peakPrice = Bars.ClosePrices[peakBarIndex];
                                _peakBar = peakBarIndex;
                                
                                // Ø±Ø³Ù… ÙÙ„Ø´ Ø¨Ù†ÙØ´ Ø±ÙˆÛŒ Ú†Ø§Ø±Øª
                                if (ShowDashboard)
                                {
                                    string arrowName = $"FractalPeak_{peakBarIndex}";
                                    Chart.DrawIcon(arrowName, ChartIconType.Diamond, peakBarIndex, _peakPrice, Color.Purple);
                                }
                                
                                _logger.Info($"ğŸ”» FRACTAL PEAK DETECTED - Bar: {peakBarIndex}, Peak Price: {_peakPrice:F5}, Start Price: {_chaosStartPrice:F5}, FD: {_peakFD:F3}");
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error($"Error in DetectFractalPeak at {index}", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CALCULATE TIP - Ù…Ø­Ø§Ø³Ø¨Ù‡ Tick Imbalance Pressure
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void CalculateTIP()
        {
            int total = _buyTicks + _sellTicks;
            
            if (total == 0)
            {
                _currentTIP = 0;
                _normalizedTIP = 0;
                return;
            }
            
            try
            {
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ TIM
                double TIM = (double)(_buyTicks - _sellTicks) / total;
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Price Range
                int idx = Bars.Count - 1;
                int lookback = Math.Min(TIPLookbackBars, idx);
                
                if (lookback < 1)
                {
                    _currentTIP = 0;
                    _normalizedTIP = 0;
                    _buyTicks = 0;
                    _sellTicks = 0;
                    return;
                }
                
                double high = Bars.HighPrices[idx];
                double low = Bars.LowPrices[idx];
                
                for (int i = 1; i <= lookback; i++)
                {
                    int id = idx - i;
                    if (id >= 0)
                    {
                        if (Bars.HighPrices[id] > high)
                            high = Bars.HighPrices[id];
                        if (Bars.LowPrices[id] < low)
                            low = Bars.LowPrices[id];
                    }
                }
                
                double range = high - low;
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ PS
                double PS = Math.Max(0.000001, range / total);
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ BAA
                double BAA = TIM >= 0 ? 
                    (double)_buyTicks / total : 
                    (double)_sellTicks / total;
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ TIP
                _currentTIP = (Math.Abs(TIM) * BAA) / PS;
                
                // Normalization - Z-Score
                _tipHistory.Enqueue(_currentTIP);
                
                if (_tipHistory.Count > TIPHistorySize)
                    _tipHistory.Dequeue();
                
                if (_tipHistory.Count >= 30)
                {
                    double[] hist = _tipHistory.ToArray();
                    double mean = hist.Average();
                    double variance = hist.Sum(t => (t - mean) * (t - mean)) / hist.Length;
                    double std = Math.Sqrt(variance);
                    
                    if (std > 1e-10)
                    {
                        _normalizedTIP = (_currentTIP - mean) / std;
                    }
                    else
                    {
                        _normalizedTIP = 0;
                    }
                }
                else
                {
                    _normalizedTIP = 0;
                }
            }
            catch (Exception ex)
            {
                _currentTIP = 0;
                _normalizedTIP = 0;
                _logger.Error("Error in CalculateTIP", ex);
            }
            finally
            {
                _buyTicks = 0;
                _sellTicks = 0;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UPDATE TOXICITY - Ø³ÛŒØ³ØªÙ… Ú¯Ø§Ø±Ø¯ Ø§Ø³Ù¾Ø±Ø¯ (FIXED LOGIC)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void UpdateToxicity()
        {
            // âœ… FIXED: Ø§Ú¯Ø± Ø®Ø§Ù…ÙˆØ´ Ø¨Ø§Ø´Ø¯ØŒ Ù‡Ù…ÛŒØ´Ù‡ safe Ùˆ warmed up
            if (!EnableToxicityGuard)
            {
                _marketSafe = true;
                _isWarmedUp = true;
                return;
            }
            
            try
            {
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Spread Ù„Ø­Ø¸Ù‡â€ŒØ§ÛŒ
                double bid = Symbol.Bid;
                double ask = Symbol.Ask;
                if (bid <= 0 || ask <= 0) return;
                
                double currentSpread = (ask - bid) / Symbol.PipSize;
                
                // Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø¯Ù‚ÛŒÙ‚Ù‡â€ŒØ§ÛŒ
                _minuteSpreads.Add(currentSpread);
                
                // Ú†Ú© Ú©Ø±Ø¯Ù† ØªØºÛŒÛŒØ± Ø¯Ù‚ÛŒÙ‚Ù‡
                int currentMinute = Server.Time.Minute;
                if (currentMinute != _lastProcessedMinute)
                {
                    if (_minuteSpreads.Count > 0)
                    {
                        _minuteSpreads.Sort();
                        double minuteMedian = _minuteSpreads[_minuteSpreads.Count / 2];
                        
                        _rollingBaseline.Enqueue(minuteMedian);
                        
                        if (_rollingBaseline.Count > WarmupMinutes)
                        {
                            _rollingBaseline.Dequeue();
                            
                            if (!_isWarmedUp)
                            {
                                _isWarmedUp = true;
                                var tempBase = _rollingBaseline.ToArray();
                                Array.Sort(tempBase);
                                _baselineSpread = tempBase[tempBase.Length / 2];
                                
                                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                                _logger.Info($"âœ… TOXICITY GUARD READY");
                                _logger.Info($"ğŸ“Š Baseline Spread: {_baselineSpread:F1} pips");
                                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                            }
                        }
                        
                        if (_rollingBaseline.Count > 0)
                        {
                            var allBaselines = _rollingBaseline.ToArray();
                            Array.Sort(allBaselines);
                            _baselineSpread = allBaselines[allBaselines.Length / 2];
                        }
                    }
                    
                    _minuteSpreads.Clear();
                    _lastProcessedMinute = currentMinute;
                }
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ù‡Ø§ÛŒÛŒ
                if (!_isWarmedUp)
                {
                    _marketSafe = false;
                    _toxicityScore = 0;
                    return;
                }
                
                double safeBaseline = _baselineSpread > 0 ? _baselineSpread : 1.0;
                _toxicityScore = currentSpread / safeBaseline;
                _marketSafe = _toxicityScore < ToxicityThreshold;
            }
            catch (Exception ex)
            {
                _logger.Error("Error in UpdateToxicity", ex);
                _marketSafe = false;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHECK ENTRY - Ø¨Ø±Ø±Ø³ÛŒ Ø´Ø±Ø§ÛŒØ· ÙˆØ±ÙˆØ¯ (FIXED LOGIC)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void CheckEntry(int index)
        {
            try
            {
                // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ø§Øª
                if (Positions.Count >= MaxPositions)
                    return;
                
                if (Positions.Any(p => p.Label == MagicNumber.ToString()))
                    return;
                
                // Ø¢ÛŒØ§ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡ØŸ
                if (_tradeTaken)
                    return;
                
                // Ø¢ÛŒØ§ Ù‚Ù„Ù‡ ÙØ±Ú©ØªØ§Ù„ÛŒ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯Ù‡ØŸ
                if (!_fractalPeakDetected)
                    return;
                
                // Ú¯Ø±ÙØªÙ† Ø±ÙˆÙ†Ø¯ ÙØ¹Ù„ÛŒ
                int trend = (int)_trendState[index];
                
                if (trend == 0)
                    return;
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // âœ… FIXED: Ù…Ù‚Ø§ÛŒØ³Ù‡ ØµØ­ÛŒØ­ Peak Price Ø¨Ø§ Start Price
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                
                TradeType? signal = null;
                string scenario = "";
                
                if (trend == 1) // Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ
                {
                    if (_peakPrice < _chaosStartPrice)
                    {
                        // Ù‚ÛŒÙ…Øª Ú©Ø§Ù‡Ø´ ÛŒØ§ÙØªÙ‡ â†’ Correction â†’ BUY
                        signal = TradeType.Buy;
                        scenario = "CORRECTION (Price dropped)";
                    }
                    else if (_peakPrice > _chaosStartPrice)
                    {
                        // Ù‚ÛŒÙ…Øª Ø§ÙØ²Ø§ÛŒØ´ ÛŒØ§ÙØªÙ‡ Ø¯Ø± Ø±ÙˆÙ†Ø¯ ØµØ¹ÙˆØ¯ÛŒ â†’ Ù…Ù…Ú©Ù† Ø§Ø³Øª Reversal Ø¨Ø§Ø´Ø¯ â†’ SELL
                        signal = TradeType.Sell;
                        scenario = "REVERSAL (Price spiked against trend)";
                        
                        // Ø¨Ø³ØªÙ† Ù¾ÙˆØ²ÛŒØ´Ù† Buy Ø¨Ø§Ø² (Ø§Ú¯Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯)
                        var openBuy = Positions.FirstOrDefault(p => p.Label == MagicNumber.ToString() && p.TradeType == TradeType.Buy);
                        if (openBuy != null)
                        {
                            _logger.Warning($"âš ï¸ REVERSAL DETECTED - Closing BUY position");
                            ClosePositionSafe(openBuy);
                        }
                    }
                }
                else if (trend == -1) // Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ
                {
                    if (_peakPrice > _chaosStartPrice)
                    {
                        // Ù‚ÛŒÙ…Øª Ø§ÙØ²Ø§ÛŒØ´ ÛŒØ§ÙØªÙ‡ â†’ Correction â†’ SELL
                        signal = TradeType.Sell;
                        scenario = "CORRECTION (Price rose)";
                    }
                    else if (_peakPrice < _chaosStartPrice)
                    {
                        // Ù‚ÛŒÙ…Øª Ú©Ø§Ù‡Ø´ ÛŒØ§ÙØªÙ‡ Ø¯Ø± Ø±ÙˆÙ†Ø¯ Ù†Ø²ÙˆÙ„ÛŒ â†’ Ù…Ù…Ú©Ù† Ø§Ø³Øª Reversal Ø¨Ø§Ø´Ø¯ â†’ BUY
                        signal = TradeType.Buy;
                        scenario = "REVERSAL (Price dropped against trend)";
                        
                        // Ø¨Ø³ØªÙ† Ù¾ÙˆØ²ÛŒØ´Ù† Sell Ø¨Ø§Ø² (Ø§Ú¯Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯)
                        var openSell = Positions.FirstOrDefault(p => p.Label == MagicNumber.ToString() && p.TradeType == TradeType.Sell);
                        if (openSell != null)
                        {
                            _logger.Warning($"âš ï¸ REVERSAL DETECTED - Closing SELL position");
                            ClosePositionSafe(openSell);
                        }
                    }
                }
                
                if (!signal.HasValue)
                    return;
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // âœ… FIXED: Ú†Ú© Ú©Ø±Ø¯Ù† Toxicity (ÙÙ‚Ø· Ø§Ú¯Ø± ÙØ¹Ø§Ù„ Ø¨Ø§Ø´Ø¯)
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if (EnableToxicityGuard)
                {
                    if (!_isWarmedUp || !_marketSafe)
                    {
                        _logger.Warning($"âš ï¸ Signal [{scenario}] BLOCKED - TOXIC market (Score: {_toxicityScore:F2})");
                        return;
                    }
                }
                
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // âœ… FIXED: Ø§Ø¬Ø±Ø§ ÛŒØ§ Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ø±Ø§ÛŒ Trigger
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info($"ğŸ¯ SIGNAL DETECTED: {scenario}");
                _logger.Info($"  Direction: {signal.Value}");
                _logger.Info($"  Trend: {(trend == 1 ? "UP" : "DOWN")}");
                _logger.Info($"  Peak Price: {_peakPrice:F5}");
                _logger.Info($"  Start Price: {_chaosStartPrice:F5}");
                _logger.Info($"  Price Delta: {(_peakPrice - _chaosStartPrice):F5}");
                _logger.Info($"  Peak FD: {_peakFD:F3}");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                if (EnableTrigger)
                {
                    // Ø°Ø®ÛŒØ±Ù‡ Ø³ÛŒÚ¯Ù†Ø§Ù„ Ø¨Ø±Ø§ÛŒ Ú†Ú© Ú©Ø±Ø¯Ù† Ø¯Ø± OnTick
                    _pendingSignal = signal.Value;
                    _logger.Info($"â³ Waiting for TIP confirmation (Threshold: {TIPZScoreThreshold})...");
                }
                else
                {
                    // âœ… FIXED: Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø³ØªÙ‚ÛŒÙ… Ø§Ú¯Ø± TIP Ø®Ø§Ù…ÙˆØ´ Ø¨Ø§Ø´Ø¯
                    ExecuteTrade(signal.Value, scenario);
                    _tradeTaken = true;
                    _fractalPeakDetected = false;  // Ø±ÛŒØ³Øª Ù‚Ù„Ù‡
                    _pendingSignal = null;
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in CheckEntry", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHECK TRIGGER EXECUTION - Ú†Ú© Ú©Ø±Ø¯Ù† TIP Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void CheckTriggerExecution()
        {
            try
            {
                if (!_pendingSignal.HasValue)
                    return;
                
                // Ú†Ú© Ú©Ø±Ø¯Ù† TIP Z-Score
                if (_normalizedTIP >= TIPZScoreThreshold)
                {
                    _logger.Info($"ğŸ”¥ TIP CONFIRMED - Z-Score: {_normalizedTIP:F2}");
                    
                    ExecuteTrade(_pendingSignal.Value, "TIP Triggered");
                    _tradeTaken = true;
                    _fractalPeakDetected = false;  // Ø±ÛŒØ³Øª Ù‚Ù„Ù‡
                    _pendingSignal = null;
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in CheckTriggerExecution", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXECUTE TRADE - Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ù‡ (FIXED STOP LOSS)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void ExecuteTrade(TradeType direction, string scenario)
        {
            try
            {
                double price = direction == TradeType.Buy ? Symbol.Ask : Symbol.Bid;
                double pZero = direction == TradeType.Buy ? _pZeroBuy : _pZeroSell;
                double stretch = Math.Abs(price - pZero);
                
                // âœ… FIXED: Ù…Ø­Ø§Ø³Ø¨Ù‡ Stop Loss Ø¨Ø§ Ø­Ø¯Ø§Ù‚Ù„ Ù…Ø·Ù„Ù‚
                double slDist;
                
                if (UseDynamicStopLoss && _atr != null && !double.IsNaN(_atr.Result.LastValue))
                {
                    // Dynamic SL based on ATR
                    double atrValue = _atr.Result.LastValue;
                    slDist = atrValue * ATRMultiplier;
                }
                else
                {
                    // Static SL based on stretch
                    slDist = stretch * 1.5; // 1.5x stretch
                }
                
                // âœ… FIXED: Ø§Ø¹Ù…Ø§Ù„ Ø­Ø¯Ø§Ù‚Ù„ Ù…Ø·Ù„Ù‚ SL (15 pips)
                double minSL = MinStopLossPips * Symbol.PipSize;
                slDist = Math.Max(slDist, minSL);
                
                // Position Sizing
                double slPips = slDist / Symbol.PipSize;
                double risk = Account.Balance * (RiskPercent / 100.0);
                double volume = risk / (slPips * Symbol.PipValue);
                
                volume = Symbol.NormalizeVolumeInUnits(volume);
                volume = Math.Max(Symbol.VolumeInUnitsMin, volume);
                volume = Math.Min(Symbol.VolumeInUnitsMax, volume);
                
                if (volume < Symbol.VolumeInUnitsMin)
                {
                    _logger.Warning($"Volume too small: {volume}");
                    return;
                }
                
                // Ù…Ø­Ø§Ø³Ø¨Ù‡ Targets
                double tp1 = pZero;
                double tp2 = direction == TradeType.Buy ? 
                    pZero + (stretch * BallisticMultiplier) : 
                    pZero - (stretch * BallisticMultiplier);
                
                // Ø§Ø¬Ø±Ø§ÛŒ Order
                var result = ExecuteMarketOrder(direction, SymbolName, volume, 
                    MagicNumber.ToString(), slPips, null);
                
                if (result != null && result.IsSuccessful && result.Position != null)
                {
                    // Ø«Ø¨Øª Context
                    lock (_tradesLock)
                    {
                        _activeTrades[result.Position.Id] = new TradeContext
                        {
                            PositionId = result.Position.Id,
                            EntryPrice = price,
                            PZero = pZero,
                            Stretch = stretch,
                            TP1 = tp1,
                            TP2 = tp2,
                            TP1Hit = false,
                            TP2Hit = false,
                            TrailingActive = false,
                            EntryBarIndex = Bars.Count - 1,
                            EntryTrendState = (int)_trendState[Bars.Count - 1],
                            Direction = direction,
                            EntryTime = Server.Time
                        };
                    }
                    
                    // Ø±ÛŒØ³Øª Ù…ØªØºÛŒØ±Ù‡Ø§
                    _chaosActive = false;
                    _fractalPeakDetected = false;
                    
                    _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    _logger.Info($"ğŸš€ TRADE EXECUTED - {scenario}");
                    _logger.Info($"Position: {result.Position.Id}");
                    _logger.Info($"Direction: {direction}");
                    _logger.Info($"Entry: {price:F5}");
                    _logger.Info($"Volume: {volume / 1000:F2} lots");
                    _logger.Info($"Stop: {slPips:F1} pips (Min: {MinStopLossPips})");
                    _logger.Info($"Risk: ${risk:F2}");
                    _logger.Info($"TP1: {tp1:F5}");
                    _logger.Info($"TP2: {tp2:F5}");
                    _logger.Info($"P-Zero: {pZero:F5}");
                    _logger.Info($"Stretch: {stretch / Symbol.PipSize:F1} pips");
                    _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                }
                else
                {
                    _logger.Error($"âŒ Trade failed: {result?.Error}");
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in ExecuteTrade", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MANAGE POSITIONS - Ù…Ø¯ÛŒØ±ÛŒØª Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø²
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void ManagePositions()
        {
            try
            {
                List<int> toRemove = new List<int>();
                List<TradeContext> contexts;
                
                lock (_tradesLock)
                {
                    contexts = _activeTrades.Values.ToList();
                }
                
                foreach (var ctx in contexts)
                {
                    var pos = Positions.FirstOrDefault(p => p.Id == ctx.PositionId);
                    
                    if (pos == null)
                    {
                        toRemove.Add(ctx.PositionId);
                        continue;
                    }
                    
                    double price = pos.TradeType == TradeType.Buy ? Symbol.Bid : Symbol.Ask;
                    int idx = Bars.Count - 1;
                    int bars = idx - ctx.EntryBarIndex;
                    
                    // Trend Reversal Exit
                    if (EnableTrendReversalExit && idx >= 0 && idx < _trendState.Count)
                    {
                        int currTrend = (int)_trendState[idx];
                        
                        if (ctx.EntryTrendState != 0 && currTrend != 0 && 
                            ctx.EntryTrendState != currTrend)
                        {
                            _logger.Info($"ğŸ”„ TREND REVERSAL - Pos {pos.Id}");
                            ClosePositionSafe(pos);
                            toRemove.Add(ctx.PositionId);
                            _perfMonitor?.RecordTrade(pos.NetProfit);
                            continue;
                        }
                    }
                    
                    // Time Stops
                    if (EnableTimeStops)
                    {
                        if (!ctx.TP1Hit && bars > TimeStop1Bars)
                        {
                            _logger.Info($"â° TIME STOP 1 - Pos {pos.Id}");
                            ClosePositionSafe(pos);
                            toRemove.Add(ctx.PositionId);
                            _perfMonitor?.RecordTrade(pos.NetProfit);
                            continue;
                        }
                        
                        if (ctx.TP1Hit && !ctx.TP2Hit && bars > TimeStop2Bars)
                        {
                            _logger.Info($"â° TIME STOP 2 - Pos {pos.Id}");
                            ClosePositionSafe(pos);
                            toRemove.Add(ctx.PositionId);
                            _perfMonitor?.RecordTrade(pos.NetProfit);
                            continue;
                        }
                    }
                    
                    // TP1
                    if (!ctx.TP1Hit)
                    {
                        bool tp1Hit = pos.TradeType == TradeType.Buy ? 
                            price >= ctx.TP1 : price <= ctx.TP1;
                        
                        if (tp1Hit)
                        {
                            double closeVol = pos.VolumeInUnits * (TP1Percent / 100.0);
                            closeVol = Symbol.NormalizeVolumeInUnits(closeVol);
                            
                            if (closeVol >= Symbol.VolumeInUnitsMin && closeVol <= pos.VolumeInUnits)
                            {
                                var res = ClosePositionSafe(pos, closeVol);
                                
                                if (res != null && res.IsSuccessful)
                                {
                                    ctx.TP1Hit = true;
                                    ctx.TrailingActive = true;
                                    ModifyPositionSafe(pos, ctx.EntryPrice, ctx.TP2);
                                    _logger.Info($"âœ… TP1 HIT - Pos {pos.Id}");
                                }
                            }
                        }
                    }
                    
                    // TP2
                    if (ctx.TP1Hit && !ctx.TP2Hit)
                    {
                        bool tp2Hit = pos.TradeType == TradeType.Buy ? 
                            price >= ctx.TP2 : price <= ctx.TP2;
                        
                        if (tp2Hit)
                        {
                            _logger.Info($"ğŸ¯ TP2 HIT - Pos {pos.Id}");
                            ClosePositionSafe(pos);
                            toRemove.Add(ctx.PositionId);
                            ctx.TP2Hit = true;
                            _perfMonitor?.RecordTrade(pos.NetProfit);
                            continue;
                        }
                    }
                    
                    // Trailing Stop
                    if (ctx.TrailingActive && _atr != null && !double.IsNaN(_atr.Result.LastValue))
                    {
                        double trailDist = _atr.Result.LastValue * TrailingATRMultiple;
                        
                        if (pos.TradeType == TradeType.Buy)
                        {
                            double newSL = price - trailDist;
                            if (pos.StopLoss == null || newSL > pos.StopLoss.Value)
                                ModifyPositionSafe(pos, newSL, pos.TakeProfit);
                        }
                        else
                        {
                            double newSL = price + trailDist;
                            if (pos.StopLoss == null || newSL < pos.StopLoss.Value)
                                ModifyPositionSafe(pos, newSL, pos.TakeProfit);
                        }
                    }
                }
                
                // Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ
                if (toRemove.Count > 0)
                {
                    lock (_tradesLock)
                    {
                        foreach (var id in toRemove)
                            _activeTrades.Remove(id);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in ManagePositions", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Helper Methods
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private TradeResult ClosePositionSafe(Position pos, double? volume = null)
        {
            try
            {
                if (pos == null)
                    return null;
                
                var result = volume.HasValue ? 
                    ClosePosition(pos, volume.Value) : 
                    ClosePosition(pos);
                
                if (result != null && result.IsSuccessful)
                    _logger.Info($"âœ… Closed {pos.Id}");
                else
                    _logger.Error($"âŒ Failed to close {pos.Id}");
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.Error($"Exception closing {pos?.Id}", ex);
                return null;
            }
        }
        
        private TradeResult ModifyPositionSafe(Position pos, double? sl, double? tp)
        {
            try
            {
                if (pos == null)
                    return null;
                
                return ModifyPosition(pos, sl, tp, ProtectionType.Absolute);
            }
            catch (Exception ex)
            {
                _logger.Error($"Exception modifying {pos?.Id}", ex);
                return null;
            }
        }
        
        private void OnPositionClosed(PositionClosedEventArgs args)
        {
            try
            {
                var pos = args.Position;
                
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info("ğŸ“Š POSITION CLOSED");
                _logger.Info($"ID: {pos.Id}");
                _logger.Info($"Direction: {pos.TradeType}");
                _logger.Info($"Entry: {pos.EntryPrice:F5}");
                _logger.Info($"P&L: ${pos.NetProfit:F2}");
                _logger.Info($"Pips: {pos.Pips:F1}");
                _logger.Info($"Reason: {args.Reason}");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                lock (_tradesLock)
                {
                    _activeTrades.Remove(pos.Id);
                }
                
                _perfMonitor?.RecordTrade(pos.NetProfit);
            }
            catch (Exception ex)
            {
                _logger.Error("Error in OnPositionClosed", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DASHBOARD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void InitializeDashboard()
        {
            if (!ShowDashboard) return;
            
            _contentPanel = new StackPanel
            {
                Orientation = Orientation.Vertical,
                Margin = 10,
                Width = 250
            };
            
            _contentPanel.AddChild(CreateHeader("âš¡ HydroDynamic v9.1"));
            
            _contentPanel.AddChild(CreateRow("Guard:", out _valGuard));
            _contentPanel.AddChild(CreateRow("Trend:", out _valTrend));
            _contentPanel.AddChild(CreateRow("State:", out _valState));
            _contentPanel.AddChild(CreateRow("P-Zero Buy:", out _valZeroBuy));
            _contentPanel.AddChild(CreateRow("P-Zero Sell:", out _valZeroSell));
            _contentPanel.AddChild(CreateRow("Trigger:", out _valTrigger));
            _contentPanel.AddChild(CreateRow("Last PnL:", out _valTrades));
            
            _mainBorder = new Border
            {
                BackgroundColor = Color.FromArgb(200, 0, 0, 0),
                BorderColor = Color.Gold,
                BorderThickness = 2,
                CornerRadius = 5,
                Child = _contentPanel,
                VerticalAlignment = VerticalAlignment.Top,
                HorizontalAlignment = HorizontalAlignment.Left,
                Margin = 20
            };
            
            Chart.AddControl(_mainBorder);
        }
        
        private StackPanel CreateRow(string title, out TextBlock valueBlock)
        {
            var rowPanel = new StackPanel 
            { 
                Orientation = Orientation.Horizontal, 
                Margin = new Thickness(0, 5, 0, 0) 
            };
            
            var lbl = new TextBlock
            {
                Text = title,
                ForegroundColor = _colTitle,
                FontWeight = FontWeight.Bold,
                Width = 100
            };
            
            valueBlock = new TextBlock
            {
                Text = "...",
                ForegroundColor = _colNeutral,
                HorizontalAlignment = HorizontalAlignment.Right
            };
            
            rowPanel.AddChild(lbl);
            rowPanel.AddChild(valueBlock);
            return rowPanel;
        }
        
        private TextBlock CreateHeader(string text)
        {
            return new TextBlock
            {
                Text = text,
                ForegroundColor = Color.Cyan,
                HorizontalAlignment = HorizontalAlignment.Center,
                FontWeight = FontWeight.ExtraBold,
                Margin = new Thickness(0, 0, 0, 10),
                FontSize = 14
            };
        }
        
        private void UpdateDashboard()
        {
            if (!ShowDashboard || _mainBorder == null) return;
            
            // Guard (Spread)
            double currentSpread = (Symbol.Ask - Symbol.Bid) / Symbol.PipSize;
            
            if (EnableToxicityGuard)
            {
                _valGuard.Text = $"{currentSpread:F1} / {(_baselineSpread > 0 ? _baselineSpread.ToString("F1") : "-")}";
                _valGuard.ForegroundColor = _marketSafe ? _colPositive : _colNegative;
            }
            else
            {
                _valGuard.Text = "OFF (Always Safe)";
                _valGuard.ForegroundColor = _colNeutral;
            }
            
            // Trend
            int tState = (int)_trendState.Last(0);
            if (tState == 1) 
            {
                _valTrend.Text = "UP â†—";
                _valTrend.ForegroundColor = _colPositive;
            }
            else if (tState == -1)
            {
                _valTrend.Text = "DOWN â†˜";
                _valTrend.ForegroundColor = _colNegative;
            }
            else
            {
                _valTrend.Text = "RANGE â†”";
                _valTrend.ForegroundColor = _colNeutral;
            }
            
            // State
            if (_chaosActive)
            {
                if (_fractalPeakDetected)
                {
                    _valState.Text = "PEAK FOUND âœ…";
                    _valState.ForegroundColor = _colPositive;
                }
                else
                {
                    _valState.Text = "CHAOS âš ï¸";
                    _valState.ForegroundColor = _colWarning;
                }
            }
            else
            {
                _valState.Text = "NORMAL";
                _valState.ForegroundColor = _colNeutral;
            }
            
            // P-Zero
            _valZeroBuy.Text = _pZeroBuy > 0 ? _pZeroBuy.ToString("F5") : "---";
            _valZeroSell.Text = _pZeroSell > 0 ? _pZeroSell.ToString("F5") : "---";
            
            // Trigger
            if (EnableTrigger)
            {
                if (_pendingSignal.HasValue)
                {
                    _valTrigger.Text = $"WAITING ({_normalizedTIP:F1})";
                    _valTrigger.ForegroundColor = _colWarning;
                }
                else if (_normalizedTIP > TIPZScoreThreshold)
                {
                    _valTrigger.Text = $"FIRE! (Z:{_normalizedTIP:F1})";
                    _valTrigger.ForegroundColor = _colPositive;
                }
                else
                {
                    _valTrigger.Text = $"ON ({_normalizedTIP:F1})";
                    _valTrigger.ForegroundColor = Color.Gray;
                }
            }
            else
            {
                _valTrigger.Text = "OFF (Direct)";
                _valTrigger.ForegroundColor = _colNeutral;
            }
            
            // Last Trade
            var lastPos = History.FindLast(MagicNumber.ToString());
            if (lastPos != null)
            {
                _valTrades.Text = $"{lastPos.NetProfit:F2}$";
                _valTrades.ForegroundColor = lastPos.NetProfit >= 0 ? _colPositive : _colNegative;
            }
            else
            {
                _valTrades.Text = "No Trades";
            }
        }
        
        private void DrawPZeroMarkers()
        {
            if (!ShowDashboard) return;
            
            int index = Bars.Count - 1;
            
            // Ø®Ø· P-Zero Buy (Ø³Ø¨Ø²)
            if (_pZeroBuy > 0)
            {
                string objBuy = "PZero_Buy";
                Chart.DrawTrendLine(objBuy, index, _pZeroBuy, index + 5, _pZeroBuy, Color.Lime, 2, LineStyle.Dots);
                Chart.DrawText(objBuy + "_txt", " Buy", index + 5, _pZeroBuy, Color.Lime);
            }
            
            // Ø®Ø· P-Zero Sell (Ù‚Ø±Ù…Ø²)
            if (_pZeroSell > 0)
            {
                string objSell = "PZero_Sell";
                Chart.DrawTrendLine(objSell, index, _pZeroSell, index + 5, _pZeroSell, Color.Red, 2, LineStyle.Dots);
                Chart.DrawText(objSell + "_txt", " Sell", index + 5, _pZeroSell, Color.Red);
            }
        }
        
        private void StopDashboard()
        {
            if (_mainBorder != null)
                Chart.RemoveControl(_mainBorder);
            
            Chart.RemoveObject("PZero_Buy");
            Chart.RemoveObject("PZero_Buy_txt");
            Chart.RemoveObject("PZero_Sell");
            Chart.RemoveObject("PZero_Sell_txt");
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ON STOP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        protected override void OnStop()
        {
            try
            {
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info("â¹ï¸  STOPPING BOT");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                if (_perfMonitor != null && ShowPerformanceStats)
                {
                    _logger.Info(_perfMonitor.GetReport());
                }
                
                lock (_tradesLock)
                {
                    _logger.Info($"Active Trades: {_activeTrades.Count}");
                    
                    if (_activeTrades.Count > 0)
                    {
                        _logger.Warning("âš ï¸ Open positions!");
                        foreach (var ctx in _activeTrades.Values)
                            _logger.Info($"  - {ctx}");
                    }
                }
                
                _logger.Info($"Market Status:");
                _logger.Info($"  P-Zero Buy: {_pZeroBuy:F5}");
                _logger.Info($"  P-Zero Sell: {_pZeroSell:F5}");
                _logger.Info($"  Chaos Active: {_chaosActive}");
                _logger.Info($"  Peak Detected: {_fractalPeakDetected}");
                _logger.Info($"  Market Safe: {_marketSafe}");
                _logger.Info($"  Toxicity: {_toxicityScore:F2}");
                
                _logger.Info(_logger.GetSummary());
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info("âœ… Bot stopped!");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                Positions.Closed -= OnPositionClosed;
                StopDashboard();
            }
            catch (Exception ex)
            {
                Print($"âŒ Error in OnStop: {ex.Message}");
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Ù¾Ø§ÛŒØ§Ù† Ú©Ø¯ - HydroDynamic Trading Bot v9.1 - FIXED & OPTIMIZED
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
