using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using cAlgo.API;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;

namespace cAlgo.Robots
{
    [Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.None)]
    public class HydroDynamicTradingBot : Robot
    {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENUMS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        public enum TrendMode
        {
            Slope,
            Cross
        }
        
        public enum TriggerMode
        {
            TTL_Legacy,
            Kinematic_Jerk,
            Permutation_Entropy,
            Hybrid_Jerk_Entropy
        }
        
        public enum LogLevel
        {
            DEBUG = 0,
            INFO = 1,
            WARNING = 2,
            ERROR = 3,
            NONE = 4
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        [Parameter("Trend Mode", DefaultValue = TrendMode.Slope, Group = "Trend")]
        public TrendMode TrendDetectionMode { get; set; }
        
        [Parameter("Fast Smooth Length", DefaultValue = 10, MinValue = 5, MaxValue = 50, Group = "Trend")]
        public int FastSmoothLength { get; set; }
        
        [Parameter("Slow Smooth Length", DefaultValue = 20, MinValue = 10, MaxValue = 100, Group = "Trend")]
        public int SlowSmoothLength { get; set; }
        
        [Parameter("Fractal Period (N)", DefaultValue = 2, MinValue = 1, MaxValue = 5, Group = "Fractal")]
        public int FractalPeriod { get; set; }
        
        [Parameter("Window Size", DefaultValue = 50, MinValue = 30, Group = "Fractal")]
        public int WindowSize { get; set; }
        
        [Parameter("Max K", DefaultValue = 8, MinValue = 2, MaxValue = 20, Group = "Fractal")]
        public int MaxK { get; set; }
        
        [Parameter("Chaos Threshold", DefaultValue = 1.65, MinValue = 1.0, MaxValue = 2.0, Group = "Fractal")]
        public double ChaosThreshold { get; set; }
        
        [Parameter("P-Zero Lookback", DefaultValue = 20, MinValue = 10, MaxValue = 100, Group = "Fractal")]
        public int PZeroLookback { get; set; }
        
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Ú¯Ø±ÙˆÙ‡ Ø¬Ø¯ÛŒØ¯: Trigger Engine (Ù…Ø§Ú˜ÙˆÙ„Ø§Ø±)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        [Parameter("Trigger Mode", DefaultValue = TriggerMode.Hybrid_Jerk_Entropy, Group = "Trigger Engine")]
        public TriggerMode SelectedTrigger { get; set; }
        
        [Parameter("Jerk Threshold", DefaultValue = 2.5, MinValue = 0.5, MaxValue = 5.0, Group = "Trigger Engine")]
        public double JerkThreshold { get; set; }
        
        [Parameter("Entropy Threshold", DefaultValue = 0.72, MinValue = 0.3, MaxValue = 1.0, Group = "Trigger Engine")]
        public double EntropyThreshold { get; set; }
        
        [Parameter("TTL Z-Score Threshold", DefaultValue = 2.0, MinValue = 1.0, MaxValue = 3.5, Group = "Trigger Engine")]
        public double TTLZScoreThreshold { get; set; }
        
        [Parameter("TTL Lookback Bars", DefaultValue = 5, MinValue = 3, MaxValue = 10, Group = "Trigger Engine")]
        public int TTLLookbackBars { get; set; }
        
        [Parameter("TTL History Size", DefaultValue = 100, MinValue = 50, MaxValue = 200, Group = "Trigger Engine")]
        public int TTLHistorySize { get; set; }
        
        [Parameter("Enable Toxicity Guard", DefaultValue = true, Group = "Toxicity")]
        public bool EnableToxicityGuard { get; set; }
        
        [Parameter("Spread History", DefaultValue = 50, MinValue = 30, MaxValue = 100, Group = "Toxicity")]
        public int SpreadHistorySize { get; set; }
        
        [Parameter("Toxicity Threshold", DefaultValue = 2.5, MinValue = 1.5, MaxValue = 5.0, Group = "Toxicity")]
        public double ToxicityThreshold { get; set; }
        
        [Parameter("Warmup Minutes", DefaultValue = 60, MinValue = 30, MaxValue = 180, Group = "Toxicity")]
        public int WarmupMinutes { get; set; }
        
        [Parameter("Risk Percent", DefaultValue = 1.0, MinValue = 0.1, MaxValue = 5.0, Group = "Risk")]
        public double RiskPercent { get; set; }
        
        [Parameter("Max Positions", DefaultValue = 1, MinValue = 1, MaxValue = 5, Group = "Risk")]
        public int MaxPositions { get; set; }
        
        [Parameter("Min Stop Loss Pips", DefaultValue = 15, MinValue = 5, MaxValue = 50, Group = "Risk")]
        public double MinStopLossPips { get; set; }
        
        [Parameter("ATR Period", DefaultValue = 14, MinValue = 5, MaxValue = 50, Group = "Risk")]
        public int ATRPeriod { get; set; }
        
        [Parameter("Use Dynamic SL", DefaultValue = true, Group = "Risk")]
        public bool UseDynamicStopLoss { get; set; }
        
        [Parameter("ATR Multiplier", DefaultValue = 2.5, MinValue = 1.0, MaxValue = 5.0, Group = "Risk")]
        public double ATRMultiplier { get; set; }
        
        [Parameter("Smart Exit Enabled", DefaultValue = true, Group = "Exit")]
        public bool SmartExitEnabled { get; set; }

        [Parameter("Chaos Threshold (FD)", DefaultValue = 1.3, MinValue = 1.0, MaxValue = 2.0, Group = "Exit")]
        public double ChaosThresholdFD { get; set; }

        [Parameter("TP1 Volume % (Stable)", DefaultValue = 10, MinValue = 0, MaxValue = 100, Group = "Exit")]
        public double TP1StablePercent { get; set; }

        [Parameter("TP1 Volume % (Chaos)", DefaultValue = 50, MinValue = 0, MaxValue = 100, Group = "Exit")]
        public double TP1ChaosPercent { get; set; }

        [Parameter("TP2 Volume % (Stable)", DefaultValue = 40, MinValue = 0, MaxValue = 100, Group = "Exit")]
        public double TP2StablePercent { get; set; }
        
        [Parameter("TP1 Close %", DefaultValue = 50, MinValue = 0, MaxValue = 100, Group = "Exit")]
        public double TP1Percent { get; set; }
        
        [Parameter("Ballistic Multiplier", DefaultValue = 1.618, MinValue = 1.0, MaxValue = 3.0, Group = "Exit")]
        public double BallisticMultiplier { get; set; }
        
        [Parameter("Trailing ATR x", DefaultValue = 1.5, MinValue = 0.5, MaxValue = 3.0, Group = "Exit")]
        public double TrailingATRMultiple { get; set; }
        
        [Parameter("Trailing Smoother Length", DefaultValue = 20, MinValue = 5, MaxValue = 50, Group = "Exit")]
        public int TrailingSmootherLength { get; set; }

        [Parameter("Trailing Offset %", DefaultValue = 0.5, MinValue = 0.1, MaxValue = 2.0, Group = "Exit")]
        public double TrailingOffsetPercent { get; set; }
        
        [Parameter("Enable Time Stops", DefaultValue = true, Group = "Exit")]
        public bool EnableTimeStops { get; set; }
        
        [Parameter("Time Stop 1", DefaultValue = 30, MinValue = 10, MaxValue = 100, Group = "Exit")]
        public int TimeStop1Bars { get; set; }
        
        [Parameter("Time Stop 2", DefaultValue = 50, MinValue = 20, MaxValue = 150, Group = "Exit")]
        public int TimeStop2Bars { get; set; }
        
        [Parameter("Trend Reversal Exit", DefaultValue = true, Group = "Exit")]
        public bool EnableTrendReversalExit { get; set; }
        
        [Parameter("Trading Enabled", DefaultValue = false, Group = "Control")]
        public bool TradingEnabled { get; set; }
        
        [Parameter("Magic Number", DefaultValue = 123456, Group = "Control")]
        public int MagicNumber { get; set; }
        
        [Parameter("Log Level", DefaultValue = LogLevel.INFO, Group = "Display")]
        public LogLevel LoggingLevel { get; set; }
        
        [Parameter("Show Stats", DefaultValue = true, Group = "Display")]
        public bool ShowPerformanceStats { get; set; }
        
        [Parameter("Show Dashboard", DefaultValue = true, Group = "Display")]
        public bool ShowDashboard { get; set; }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private IndicatorDataSeries _fastSmooth;
        private IndicatorDataSeries _slowSmooth;
        private IndicatorDataSeries _trendState;
        private IndicatorDataSeries _fractalDimension;
        private IndicatorDataSeries _trailingSmooth;
        
        private double _c1Fast, _c2Fast, _c3Fast;
        private double _c1Slow, _c2Slow, _c3Slow;
        private double _c1Trailing, _c2Trailing, _c3Trailing;
        
        private Queue<double> _fdBuffer;
        private int _fdBufferSize;
        
        private double _pZeroBuy;
        private double _pZeroSell;
        
        private bool _chaosActive;
        private double _chaosStartPrice;
        private int _chaosStartBar;
        private bool _fractalPeakDetected;
        private double _peakFD;
        private double _peakPrice;
        private int _peakBar;
        
        private TradeType? _pendingSignal;
        private bool _tradeTaken;
        
        private List<double> _minuteSpreads;
        private Queue<double> _rollingBaseline;
        private double _baselineSpread;
        private double _toxicityScore;
        private bool _marketSafe;
        private int _lastProcessedMinute;
        private bool _isWarmedUp;
        private List<double> _xValues;
        private List<double> _yValues;
        
        private Dictionary<int, TradeContext> _activeTrades;
        private readonly object _tradesLock = new object();
        
        private AverageTrueRange _atr;
        
        private Logger _logger;
        private PerformanceMonitor _perfMonitor;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Trigger Engines (NEW MODULAR ARCHITECTURE)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private LegacyTIPEngine _legacyTip;
        private JerkEngine _jerkEngine;
        private EntropyEngine _entropyEngine;
        
        // Dashboard
        private Border _mainBorder;
        private StackPanel _contentPanel;
        private TextBlock _valGuard;
        private TextBlock _valTrend;
        private TextBlock _valState;
        private TextBlock _valZeroBuy;
        private TextBlock _valZeroSell;
        private TextBlock _valTrigger;
        private TextBlock _valTrades;
        
        private readonly Color _colTitle = Color.Gold;
        private readonly Color _colPositive = Color.Lime;
        private readonly Color _colNegative = Color.Red;
        private readonly Color _colNeutral = Color.WhiteSmoke;
        private readonly Color _colWarning = Color.Orange;
        
        private DateTime _lastDashUpdate;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS: Logger
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private class Logger
        {
            private readonly Robot _robot;
            private readonly LogLevel _level;
            private readonly StringBuilder _buffer;
            private int _logCount;
            
            public Logger(Robot robot, LogLevel level)
            {
                _robot = robot;
                _level = level;
                _buffer = new StringBuilder();
                _logCount = 0;
            }
            
            public void Debug(string message)
            {
                if (_level <= LogLevel.DEBUG)
                    Log("DEBUG", message, "ğŸ”");
            }
            
            public void Info(string message)
            {
                if (_level <= LogLevel.INFO)
                    Log("INFO", message, "â„¹ï¸");
            }
            
            public void Warning(string message)
            {
                if (_level <= LogLevel.WARNING)
                    Log("WARN", message, "âš ï¸");
            }
            
            public void Error(string message, Exception ex = null)
            {
                if (_level <= LogLevel.ERROR)
                {
                    string full = message;
                    if (ex != null)
                        full += $"\nException: {ex.Message}";
                    Log("ERROR", full, "âŒ");
                }
            }
            
            private void Log(string level, string message, string icon)
            {
                _logCount++;
                string time = _robot.Server.Time.ToString("HH:mm:ss");
                string formatted = $"[{time}] {icon} {level}: {message}";
                _robot.Print(formatted);
                _buffer.AppendLine(formatted);
                
                if (_logCount % 1000 == 0)
                    _buffer.Clear();
            }
            
            public string GetSummary()
            {
                return $"Total logs: {_logCount}";
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS: Performance Monitor
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private class PerformanceMonitor
        {
            private DateTime _startTime;
            private int _totalTrades;
            private int _winningTrades;
            private int _losingTrades;
            private double _totalProfit;
            private double _totalLoss;
            private double _largestWin;
            private double _largestLoss;
            
            public void Start()
            {
                _startTime = DateTime.UtcNow;
                _totalTrades = 0;
                _winningTrades = 0;
                _losingTrades = 0;
                _totalProfit = 0;
                _totalLoss = 0;
                _largestWin = 0;
                _largestLoss = 0;
            }
            
            public void RecordTrade(double pnl)
            {
                _totalTrades++;
                
                if (pnl > 0)
                {
                    _winningTrades++;
                    _totalProfit += pnl;
                    if (pnl > _largestWin)
                        _largestWin = pnl;
                }
                else
                {
                    _losingTrades++;
                    _totalLoss += Math.Abs(pnl);
                    if (Math.Abs(pnl) > _largestLoss)
                        _largestLoss = Math.Abs(pnl);
                }
            }
            
            public string GetReport()
            {
                var sb = new StringBuilder();
                var runtime = DateTime.UtcNow - _startTime;
                
                sb.AppendLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                sb.AppendLine("ğŸ“Š PERFORMANCE SUMMARY");
                sb.AppendLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                sb.AppendLine($"Runtime: {runtime.Days}d {runtime.Hours}h {runtime.Minutes}m");
                sb.AppendLine($"Total Trades: {_totalTrades}");
                sb.AppendLine($"Winning: {_winningTrades} ({(_totalTrades > 0 ? (double)_winningTrades / _totalTrades * 100 : 0):F1}%)");
                sb.AppendLine($"Losing: {_losingTrades} ({(_totalTrades > 0 ? (double)_losingTrades / _totalTrades * 100 : 0):F1}%)");
                sb.AppendLine($"Total Profit: ${_totalProfit:F2}");
                sb.AppendLine($"Total Loss: ${_totalLoss:F2}");
                sb.AppendLine($"Net P&L: ${(_totalProfit - _totalLoss):F2}");
                sb.AppendLine($"Largest Win: ${_largestWin:F2}");
                sb.AppendLine($"Largest Loss: ${_largestLoss:F2}");
                
                if (_totalTrades > 0)
                {
                    double avgWin = _winningTrades > 0 ? _totalProfit / _winningTrades : 0;
                    double avgLoss = _losingTrades > 0 ? _totalLoss / _losingTrades : 0;
                    double profitFactor = _totalLoss > 0 ? _totalProfit / _totalLoss : 0;
                    
                    sb.AppendLine($"Avg Win: ${avgWin:F2}");
                    sb.AppendLine($"Avg Loss: ${avgLoss:F2}");
                    sb.AppendLine($"Profit Factor: {profitFactor:F2}");
                }
                
                sb.AppendLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                return sb.ToString();
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLASS: Trade Context
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private class TradeContext
        {
            public int PositionId { get; set; }
            public double EntryPrice { get; set; }
            public double PZero { get; set; }
            public double Stretch { get; set; }
            public double TP1 { get; set; }
            public double TP2 { get; set; }
            public bool TP1Hit { get; set; }
            public bool TP2Hit { get; set; }
            public bool TrailingActive { get; set; }
            public int EntryBarIndex { get; set; }
            public int EntryTrendState { get; set; }
            public TradeType Direction { get; set; }
            public DateTime EntryTime { get; set; }
            public double OriginalVolume { get; set; }
            
            public override string ToString()
            {
                return $"Pos {PositionId}: {Direction} @ {EntryPrice:F5}, P_zero={PZero:F5}";
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TRIGGER ENGINE 1: Legacy TIP (TTL)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private class LegacyTIPEngine
        {
            private readonly Robot _robot;
            private readonly Symbol _symbol;
            private readonly double _threshold;
            private readonly int _lookbackBars;
            private readonly int _historySize;
            
            private int _buyTicks;
            private int _sellTicks;
            private double _lastAsk;
            private double _currentTIP;
            private Queue<double> _tipHistory;
            private double _normalizedTIP;
            
            public double ZScore => _normalizedTIP;
            public bool IsTriggered => _normalizedTIP >= _threshold;
            
            public LegacyTIPEngine(Robot robot, Symbol symbol, double threshold, int lookbackBars, int historySize)
            {
                _robot = robot;
                _symbol = symbol;
                _threshold = threshold;
                _lookbackBars = lookbackBars;
                _historySize = historySize;
                
                _buyTicks = 0;
                _sellTicks = 0;
                _lastAsk = symbol.Ask;
                _currentTIP = 0;
                _normalizedTIP = 0;
                _tipHistory = new Queue<double>();
            }
            
            public void OnTick()
            {
                double currentAsk = _symbol.Ask;
                
                if (currentAsk > _lastAsk)
                    _buyTicks++;
                else if (currentAsk < _lastAsk)
                    _sellTicks++;
                
                _lastAsk = currentAsk;
            }
            
            public void OnBar(Bars bars)
            {
                int total = _buyTicks + _sellTicks;
                
                if (total == 0)
                {
                    _currentTIP = 0;
                    _normalizedTIP = 0;
                    return;
                }
                
                try
                {
                    double TIM = (double)(_buyTicks - _sellTicks) / total;
                    
                    int idx = bars.Count - 1;
                    int lookback = Math.Min(_lookbackBars, idx);
                    
                    if (lookback < 1)
                    {
                        _currentTIP = 0;
                        _normalizedTIP = 0;
                        _buyTicks = 0;
                        _sellTicks = 0;
                        return;
                    }
                    
                    double high = bars.HighPrices[idx];
                    double low = bars.LowPrices[idx];
                    
                    for (int i = 1; i <= lookback; i++)
                    {
                        int id = idx - i;
                        if (id >= 0)
                        {
                            if (bars.HighPrices[id] > high)
                                high = bars.HighPrices[id];
                            if (bars.LowPrices[id] < low)
                                low = bars.LowPrices[id];
                        }
                    }
                    
                    double range = high - low;
                    double PS = Math.Max(0.000001, range / total);
                    double BAA = TIM >= 0 ? (double)_buyTicks / total : (double)_sellTicks / total;
                    
                    _currentTIP = (Math.Abs(TIM) * BAA) / PS;
                    
                    _tipHistory.Enqueue(_currentTIP);
                    
                    if (_tipHistory.Count > _historySize)
                        _tipHistory.Dequeue();
                    
                    if (_tipHistory.Count >= 30)
                    {
                        double[] hist = _tipHistory.ToArray();
                        double mean = hist.Average();
                        double variance = hist.Sum(t => (t - mean) * (t - mean)) / hist.Length;
                        double std = Math.Sqrt(variance);
                        
                        if (std > 1e-10)
                        {
                            _normalizedTIP = (_currentTIP - mean) / std;
                        }
                        else
                        {
                            _normalizedTIP = 0;
                        }
                    }
                    else
                    {
                        _normalizedTIP = 0;
                    }
                }
                catch
                {
                    _currentTIP = 0;
                    _normalizedTIP = 0;
                }
                finally
                {
                    _buyTicks = 0;
                    _sellTicks = 0;
                }
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TRIGGER ENGINE 2: Kinematic Jerk (Savitzky-Golay 3rd Derivative)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private class JerkEngine
        {
            private readonly double _threshold;
            private readonly AverageTrueRange _atr;
            private readonly Queue<double> _priceBuffer;
            private const int BufferSize = 5;
            
            public double Value { get; private set; }
            public bool IsTriggered => Value >= _threshold;
            
            public JerkEngine(double threshold, AverageTrueRange atr)
            {
                _threshold = threshold;
                _atr = atr;
                _priceBuffer = new Queue<double>(BufferSize);
                Value = 0;
            }
            
            public void OnBar(double closePrice)
            {
                _priceBuffer.Enqueue(closePrice);
                
                if (_priceBuffer.Count > BufferSize)
                    _priceBuffer.Dequeue();
                
                if (_priceBuffer.Count < BufferSize)
                {
                    Value = 0;
                    return;
                }
                
                try
                {
                    var prices = _priceBuffer.ToArray();
                    
                    // Savitzky-Golay coefficients for 3rd derivative (5-point stencil)
                    // J(t) = [p(t-2) - 2*p(t-1) + 2*p(t+1) - p(t+2)] / 2
                    // Note: p(t) has weight 0 in this specific formulation
                    double rawJerk = (prices[0] - 2.0 * prices[1] + 2.0 * prices[3] - prices[4]) / 2.0;
                    
                    // Normalize by ATR
                    if (_atr != null && !double.IsNaN(_atr.Result.LastValue) && _atr.Result.LastValue > 0)
                    {
                        Value = Math.Abs(rawJerk) / _atr.Result.LastValue;
                    }
                    else
                    {
                        Value = 0;
                    }
                }
                catch
                {
                    Value = 0;
                }
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TRIGGER ENGINE 3: Permutation Entropy (Order Pattern Analysis)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private class EntropyEngine
        {
            private readonly double _threshold;
            private const int Dimension = 5;
            private const int WindowSize = 50;
            
            private readonly Queue<double> _priceBuffer;
            private readonly Dictionary<string, int> _patternCounts;
            
            public double Value { get; private set; }
            public bool IsSafe => Value < _threshold;
            
            public EntropyEngine(double threshold)
            {
                _threshold = threshold;
                _priceBuffer = new Queue<double>(WindowSize);
                _patternCounts = new Dictionary<string, int>();
                Value = 1.0; // Start unsafe until warmed up
            }
            
            public void OnBar(double closePrice)
            {
                _priceBuffer.Enqueue(closePrice);
                
                if (_priceBuffer.Count > WindowSize)
                    _priceBuffer.Dequeue();
                
                if (_priceBuffer.Count < WindowSize)
                {
                    Value = 1.0;
                    return;
                }
                
                try
                {
                    _patternCounts.Clear();
                    var prices = _priceBuffer.ToArray();
                    
                    // Generate all patterns in the window
                    for (int i = 0; i <= prices.Length - Dimension; i++)
                    {
                        string pattern = GetOrdinalPattern(prices, i, Dimension);
                        
                        if (_patternCounts.ContainsKey(pattern))
                            _patternCounts[pattern]++;
                        else
                            _patternCounts[pattern] = 1;
                    }
                    
                    // Calculate Shannon Entropy
                    double entropy = 0.0;
                    int totalPatterns = _patternCounts.Values.Sum();
                    
                    foreach (var count in _patternCounts.Values)
                    {
                        double p = (double)count / totalPatterns;
                        if (p > 0)
                            entropy -= p * Math.Log(p);
                    }
                    
                    // Normalize (max entropy for 5! = 120 permutations is ln(120) â‰ˆ 4.787)
                    double maxEntropy = Math.Log(Factorial(Dimension));
                    Value = maxEntropy > 0 ? entropy / maxEntropy : 0;
                }
                catch
                {
                    Value = 1.0;
                }
            }
            
            private string GetOrdinalPattern(double[] prices, int startIndex, int dimension)
            {
                var segment = new double[dimension];
                var indices = new int[dimension];
                
                for (int i = 0; i < dimension; i++)
                {
                    segment[i] = prices[startIndex + i];
                    indices[i] = i;
                }
                
                // Sort indices by segment values
                Array.Sort(segment, indices);
                
                // Create pattern string
                return string.Join(",", indices);
            }
            
            private int Factorial(int n)
            {
                int result = 1;
                for (int i = 2; i <= n; i++)
                    result *= i;
                return result;
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ON START
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        protected override void OnStart()
        {
            try
            {
                _logger = new Logger(this, LoggingLevel);
                _perfMonitor = new PerformanceMonitor();
                _perfMonitor.Start();
                
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info(" HydroDynamic Bot v10.0 - QUANTUM-KINETIC");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info($" Symbol: {SymbolName}");
                _logger.Info($" Timeframe: {TimeFrame}");
                _logger.Info($" Trend Mode: {TrendDetectionMode}");
                _logger.Info($" Trigger Mode: {SelectedTrigger}");
                _logger.Info($" Trading: {(TradingEnabled ? "ON âœ…" : "OFF âš ï¸")}");
                _logger.Info($" Toxicity Guard: {(EnableToxicityGuard ? "ON" : "OFF")}");
                _logger.Info($" Min SL: {MinStopLossPips} pips");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                _fastSmooth = CreateDataSeries();
                _slowSmooth = CreateDataSeries();
                _trendState = CreateDataSeries();
                _fractalDimension = CreateDataSeries();
                _trailingSmooth = CreateDataSeries();
                
                CalculateSuperSmootherCoefficients(FastSmoothLength, out _c1Fast, out _c2Fast, out _c3Fast);
                
                if (TrendDetectionMode == TrendMode.Cross)
                {
                    CalculateSuperSmootherCoefficients(SlowSmoothLength, out _c1Slow, out _c2Slow, out _c3Slow);
                }
                
                CalculateSuperSmootherCoefficients(TrailingSmootherLength, out _c1Trailing, out _c2Trailing, out _c3Trailing);
                
                _fdBufferSize = (FractalPeriod * 2) + 1;
                _fdBuffer = new Queue<double>(_fdBufferSize);
                
                _pZeroBuy = 0;
                _pZeroSell = 0;
                
                _chaosActive = false;
                _chaosStartPrice = 0;
                _chaosStartBar = -1;
                _fractalPeakDetected = false;
                _peakFD = 0;
                _peakPrice = 0;
                _peakBar = -1;
                
                _pendingSignal = null;
                _tradeTaken = false;
                
                _minuteSpreads = new List<double>();
                _rollingBaseline = new Queue<double>();
                _baselineSpread = 0;
                _toxicityScore = 0;
                _marketSafe = !EnableToxicityGuard;
                _lastProcessedMinute = Server.Time.Minute;
                _isWarmedUp = !EnableToxicityGuard;
                
                _activeTrades = new Dictionary<int, TradeContext>();
                _atr = Indicators.AverageTrueRange(ATRPeriod, MovingAverageType.Simple);
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Initialize Trigger Engines (MODULAR ARCHITECTURE)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                switch (SelectedTrigger)
                {
                    case TriggerMode.TTL_Legacy:
                        _legacyTip = new LegacyTIPEngine(this, Symbol, TTLZScoreThreshold, TTLLookbackBars, TTLHistorySize);
                        _logger.Info("âœ… TTL Engine Initialized");
                        break;
                        
                    case TriggerMode.Kinematic_Jerk:
                        _jerkEngine = new JerkEngine(JerkThreshold, _atr);
                        _logger.Info("âœ… Jerk Engine Initialized");
                        break;
                        
                    case TriggerMode.Permutation_Entropy:
                        _entropyEngine = new EntropyEngine(EntropyThreshold);
                        _logger.Info("âœ… Entropy Engine Initialized");
                        break;
                        
                    case TriggerMode.Hybrid_Jerk_Entropy:
                        _jerkEngine = new JerkEngine(JerkThreshold, _atr);
                        _entropyEngine = new EntropyEngine(EntropyThreshold);
                        _logger.Info("âœ… Hybrid Engine Initialized (Jerk + Entropy)");
                        break;
                }
                
                int lookback = Math.Min(300, Bars.Count);
                int startIndex = Math.Max(0, Bars.Count - lookback);
                
                _logger.Info($"â³ Warming up indicators (Last {lookback} bars)...");
                _xValues = new List<double>(MaxK);
                _yValues = new List<double>(MaxK);

                for (int i = startIndex; i < Bars.Count; i++)
                {
                    CalculateTrend(i);
                    CalculateFD(i);
                    UpdateDualPZero(i);
                }
                
                _logger.Info($"âœ… Ready - {Bars.Count} bars processed");
                
                Positions.Closed += OnPositionClosed;
                
                if (ShowDashboard)
                {
                    InitializeDashboard();
                }
                
                _logger.Info("ğŸš€ Bot started successfully!");
            }
            catch (Exception ex)
            {
                Print($"âŒ CRITICAL: {ex.Message}");
                Stop();
            }
        }
        
        private void CalculateSuperSmootherCoefficients(int length, out double c1, out double c2, out double c3)
        {
            double arg = 1.414 * Math.PI / length;
            double a1 = Math.Exp(-arg);
            double b1 = 2.0 * a1 * Math.Cos(arg);
            
            c2 = b1;
            c3 = -a1 * a1;
            c1 = (1.0 - c2 - c3) / 2.0;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ON TICK
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        protected override void OnTick()
        {
            try
            {
                // Update Trigger Engines (if applicable)
                if (SelectedTrigger == TriggerMode.TTL_Legacy)
                {
                    _legacyTip?.OnTick();
                }
                
                if (TradingEnabled && _activeTrades.Count > 0)
                {
                    ManagePositions();
                }
                
                if (EnableToxicityGuard)
                {
                    UpdateToxicity();
                }
                
                if (_pendingSignal.HasValue && !_tradeTaken)
                {
                    CheckTriggerExecution();
                }
                
                if (ShowDashboard && (Server.Time - _lastDashUpdate).TotalSeconds >= 1)
                {
                    try 
                    { 
                        UpdateDashboard(); 
                        _lastDashUpdate = Server.Time; 
                    } 
                    catch { }
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in OnTick", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ON BAR
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        protected override void OnBar()
        {
            try
            {
                int index = Bars.Count - 1;
                
                CalculateTrend(index);
                CalculateFD(index);
                UpdateDualPZero(index);
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Update Trigger Engines (MODULAR DISPATCH)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                double closePrice = Bars.ClosePrices[index];
                
                switch (SelectedTrigger)
                {
                    case TriggerMode.TTL_Legacy:
                        _legacyTip?.OnBar(Bars);
                        break;
                        
                    case TriggerMode.Kinematic_Jerk:
                        _jerkEngine?.OnBar(closePrice);
                        break;
                        
                    case TriggerMode.Permutation_Entropy:
                        _entropyEngine?.OnBar(closePrice);
                        break;
                        
                    case TriggerMode.Hybrid_Jerk_Entropy:
                        _jerkEngine?.OnBar(closePrice);
                        _entropyEngine?.OnBar(closePrice);
                        break;
                }
                
                DetectFractalPeak(index);
                
                if (TradingEnabled)
                {
                    CheckEntry(index);
                }
                
                if (ShowDashboard)
                {
                    DrawPZeroMarkers();
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in OnBar", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CALCULATE TREND
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void CalculateTrend(int index)
        {
            if (index < 2)
            {
                _fastSmooth[index] = Bars.ClosePrices[index];
                _slowSmooth[index] = Bars.ClosePrices[index];
                _trailingSmooth[index] = Bars.ClosePrices[index];
                _trendState[index] = 0;
                return;
            }
            
            try
            {
                double priceAvgFast = (Bars.ClosePrices[index] + Bars.ClosePrices[index - 1]) / 2.0;
                
                _fastSmooth[index] = _c1Fast * priceAvgFast
                                   + _c2Fast * _fastSmooth[index - 1]
                                   + _c3Fast * _fastSmooth[index - 2];
                
                double priceAvgTrailing = (Bars.ClosePrices[index] + Bars.ClosePrices[index - 1]) / 2.0;
                
                _trailingSmooth[index] = _c1Trailing * priceAvgTrailing
                                       + _c2Trailing * _trailingSmooth[index - 1]
                                       + _c3Trailing * _trailingSmooth[index - 2];
                
                if (TrendDetectionMode == TrendMode.Slope)
                {
                    if (_fastSmooth[index] > _fastSmooth[index - 1])
                    {
                        _trendState[index] = 1;
                    }
                    else if (_fastSmooth[index] < _fastSmooth[index - 1])
                    {
                        _trendState[index] = -1;
                    }
                    else
                    {
                        _trendState[index] = 0;
                    }
                }
                else
                {
                    double priceAvgSlow = (Bars.ClosePrices[index] + Bars.ClosePrices[index - 1]) / 2.0;
                    
                    _slowSmooth[index] = _c1Slow * priceAvgSlow
                                       + _c2Slow * _slowSmooth[index - 1]
                                       + _c3Slow * _slowSmooth[index - 2];
                    
                    if (_fastSmooth[index] > _slowSmooth[index])
                    {
                        _trendState[index] = 1;
                    }
                    else if (_fastSmooth[index] < _slowSmooth[index])
                    {
                        _trendState[index] = -1;
                    }
                    else
                    {
                        _trendState[index] = 0;
                    }
                }
            }
            catch (Exception ex)
            {
                _trendState[index] = 0;
                _logger.Error($"Error in CalculateTrend at {index}", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CALCULATE FD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void CalculateFD(int index)
        {
            if (index < WindowSize - 1)
            {
                _fractalDimension[index] = 1.0;
                return;
            }
            
            try
            {
                _xValues.Clear();
                _yValues.Clear();
                
                int startIdx = index - WindowSize + 1;
                
                for (int k = 1; k <= MaxK; k++)
                {
                    double lengthSum = 0.0;
                    int validSubsets = 0;
                    
                    for (int m = 0; m < k; m++)
                    {
                        double Lmk = 0.0;
                        int points = (WindowSize - m - 1) / k;
                        
                        if (points < 1)
                            continue;
                        
                        for (int i = 1; i <= points; i++)
                        {
                            int currIdx = startIdx + m + i * k;
                            int prevIdx = startIdx + m + (i - 1) * k;
                            
                            if (currIdx >= Bars.Count || prevIdx >= Bars.Count)
                                continue;
                            
                            Lmk += Math.Abs(Bars.ClosePrices[currIdx] - Bars.ClosePrices[prevIdx]);
                        }
                        
                        double norm = (WindowSize - 1.0) / (points * k * k);
                        lengthSum += Lmk * norm;
                        validSubsets++;
                    }
                    
                    if (validSubsets > 0)
                    {
                        double avgLk = lengthSum / validSubsets;
                        if (avgLk > 0 && !double.IsNaN(avgLk) && !double.IsInfinity(avgLk))
                        {
                            _xValues.Add(Math.Log(1.0 / k));
                            _yValues.Add(Math.Log(avgLk));
                        }
                    }
                }
                
                if (_xValues.Count < 2)
                {
                    _fractalDimension[index] = 1.0;
                    return;
                }
                
                double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
                int n = _xValues.Count;
                
                for (int i = 0; i < n; i++)
                {
                    sumX += _xValues[i];
                    sumY += _yValues[i];
                    sumXY += _xValues[i] * _yValues[i];
                    sumX2 += _xValues[i] * _xValues[i];
                }
                
                double denom = n * sumX2 - sumX * sumX;
                
                if (Math.Abs(denom) < 1e-10)
                {
                    _fractalDimension[index] = 1.0;
                    return;
                }
                
                double fd = (n * sumXY - sumX * sumY) / denom;
                _fractalDimension[index] = Math.Max(1.0, Math.Min(2.0, fd));
            }
            catch (Exception ex)
            {
                _fractalDimension[index] = 1.0;
                _logger.Error($"Error in CalculateFD at {index}", ex);
            }
        }
        
        private void UpdateDualPZero(int index)
        {
            if (index < 0)
                return;
            
            try
            {
                _pZeroBuy = Bars.HighPrices[index];
                
                int startBuy = Math.Max(0, index - PZeroLookback + 1);
                for (int i = startBuy; i <= index; i++)
                {
                    if (Bars.HighPrices[i] > _pZeroBuy)
                        _pZeroBuy = Bars.HighPrices[i];
                }
                
                _pZeroSell = Bars.LowPrices[index];
                
                int startSell = Math.Max(0, index - PZeroLookback + 1);
                for (int i = startSell; i <= index; i++)
                {
                    if (Bars.LowPrices[i] < _pZeroSell)
                        _pZeroSell = Bars.LowPrices[i];
                }
            }
            catch (Exception ex)
            {
                _logger.Error($"Error in UpdateDualPZero at {index}", ex);
            }
        }
        
        private void DetectFractalPeak(int index)
        {
            try
            {
                double currentFD = _fractalDimension[index];
                
                if (!_chaosActive && currentFD >= ChaosThreshold)
                {
                    _chaosActive = true;
                    _chaosStartPrice = Bars.ClosePrices[index];
                    _chaosStartBar = index;
                    _tradeTaken = false;
                    
                    _logger.Info($"ğŸŒ€ CHAOS STARTED - Bar: {index}, Price: {_chaosStartPrice:F5}, FD: {currentFD:F3}");
                }
                
                _fdBuffer.Enqueue(currentFD);
                
                if (_fdBuffer.Count > _fdBufferSize)
                    _fdBuffer.Dequeue();
                
                if (_fdBuffer.Count == _fdBufferSize)
                {
                    var fdArray = _fdBuffer.ToArray();
                    int middleIndex = FractalPeriod;
                    double middleValue = fdArray[middleIndex];
                    
                    bool isPeak = true;
                    
                    for (int i = 0; i < middleIndex; i++)
                    {
                        if (fdArray[i] >= middleValue)
                        {
                            isPeak = false;
                            break;
                        }
                    }
                    
                    if (isPeak)
                    {
                        for (int i = middleIndex + 1; i < _fdBufferSize; i++)
                        {
                            if (fdArray[i] >= middleValue)
                            {
                                isPeak = false;
                                break;
                            }
                        }
                    }
                    
                    if (isPeak && _chaosActive)
                    {
                        int peakBarIndex = index - FractalPeriod;
                        
                        if (peakBarIndex >= _chaosStartBar)
                        {
                            if (middleValue >= ChaosThreshold)
                            {
                                _fractalPeakDetected = true;
                                _peakFD = middleValue;
                                _peakPrice = Bars.ClosePrices[peakBarIndex];
                                _peakBar = peakBarIndex;
                                
                                if (ShowDashboard)
                                {
                                    string arrowName = $"FractalPeak_{peakBarIndex}";
                                    Chart.DrawIcon(arrowName, ChartIconType.Diamond, peakBarIndex, _peakPrice, Color.Purple);
                                }
                                
                                _logger.Info($"ğŸ”» FRACTAL PEAK DETECTED - Bar: {peakBarIndex}, Peak Price: {_peakPrice:F5}, Start Price: {_chaosStartPrice:F5}, FD: {_peakFD:F3}");
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error($"Error in DetectFractalPeak at {index}", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHECK ENTRY (MODULAR TRAFFIC COP)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void CheckEntry(int index)
        {
            try
            {
                if (Positions.Count >= MaxPositions)
                    return;
                
                if (Positions.Any(p => p.Label == MagicNumber.ToString()))
                    return;
                
                if (_tradeTaken)
                    return;
                
                if (!_fractalPeakDetected)
                    return;
                
                int trend = (int)_trendState[index];
                
                if (trend == 0)
                    return;
                
                TradeType? signal = null;
                string scenario = "";
                
                if (trend == 1)
                {
                    if (_peakPrice < _chaosStartPrice)
                    {
                        signal = TradeType.Buy;
                        scenario = "CORRECTION (Price dropped)";
                    }
                    else if (_peakPrice > _chaosStartPrice)
                    {
                        signal = TradeType.Sell;
                        scenario = "REVERSAL (Price spiked against trend)";
                        
                        var openBuy = Positions.FirstOrDefault(p => p.Label == MagicNumber.ToString() && p.TradeType == TradeType.Buy);
                        if (openBuy != null)
                        {
                            _logger.Warning($"âš ï¸ REVERSAL DETECTED - Closing BUY position");
                            ClosePositionSafe(openBuy);
                        }
                    }
                }
                else if (trend == -1)
                {
                    if (_peakPrice > _chaosStartPrice)
                    {
                        signal = TradeType.Sell;
                        scenario = "CORRECTION (Price rose)";
                    }
                    else if (_peakPrice < _chaosStartPrice)
                    {
                        signal = TradeType.Buy;
                        scenario = "REVERSAL (Price dropped against trend)";
                        
                        var openSell = Positions.FirstOrDefault(p => p.Label == MagicNumber.ToString() && p.TradeType == TradeType.Sell);
                        if (openSell != null)
                        {
                            _logger.Warning($"âš ï¸ REVERSAL DETECTED - Closing SELL position");
                            ClosePositionSafe(openSell);
                        }
                    }
                }
                
                if (!signal.HasValue)
                    return;
                
                if (EnableToxicityGuard)
                {
                    if (!_isWarmedUp || !_marketSafe)
                    {
                        _logger.Warning($"âš ï¸ Signal [{scenario}] BLOCKED - TOXIC market (Score: {_toxicityScore:F2})");
                        return;
                    }
                }
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // THE TRAFFIC COP: Modular Trigger Dispatch
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                bool isTriggerValid = false;
                double triggerValueDisplay = 0;
                
                switch (SelectedTrigger)
                {
                    case TriggerMode.TTL_Legacy:
                        triggerValueDisplay = _legacyTip.ZScore;
                        isTriggerValid = _legacyTip.IsTriggered;
                        break;
                        
                    case TriggerMode.Kinematic_Jerk:
                        triggerValueDisplay = _jerkEngine.Value;
                        isTriggerValid = _jerkEngine.IsTriggered;
                        break;
                        
                    case TriggerMode.Permutation_Entropy:
                        triggerValueDisplay = _entropyEngine.Value;
                        isTriggerValid = _entropyEngine.IsSafe;
                        break;
                        
                    case TriggerMode.Hybrid_Jerk_Entropy:
                        double jerkVal = _jerkEngine.Value;
                        double peVal = _entropyEngine.Value;
                        
                        triggerValueDisplay = jerkVal;
                        
                        bool hasShock = _jerkEngine.IsTriggered;
                        bool isOrdered = _entropyEngine.IsSafe;
                        
                        isTriggerValid = hasShock && isOrdered;
                        break;
                }
                
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info($"ğŸ¯ SIGNAL DETECTED: {scenario}");
                _logger.Info($"  Direction: {signal.Value}");
                _logger.Info($"  Trend: {(trend == 1 ? "UP" : "DOWN")}");
                _logger.Info($"  Peak Price: {_peakPrice:F5}");
                _logger.Info($"  Start Price: {_chaosStartPrice:F5}");
                _logger.Info($"  Price Delta: {(_peakPrice - _chaosStartPrice):F5}");
                _logger.Info($"  Peak FD: {_peakFD:F3}");
                _logger.Info($"  Trigger Mode: {SelectedTrigger}");
                _logger.Info($"  Trigger Value: {triggerValueDisplay:F3}");
                _logger.Info($"  Trigger Valid: {isTriggerValid}");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                if (isTriggerValid)
                {
                    ExecuteTrade(signal.Value, scenario);
                    _tradeTaken = true;
                    _fractalPeakDetected = false;
                    _pendingSignal = null;
                }
                else
                {
                    _pendingSignal = signal.Value;
                    _logger.Info($"â³ Waiting for Trigger confirmation...");
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in CheckEntry", ex);
            }
        }
        
        private void CheckTriggerExecution()
        {
            try
            {
                if (!_pendingSignal.HasValue)
                    return;
                
                bool isTriggerValid = false;
                
                switch (SelectedTrigger)
                {
                    case TriggerMode.TTL_Legacy:
                        isTriggerValid = _legacyTip.IsTriggered;
                        break;
                        
                    case TriggerMode.Kinematic_Jerk:
                        isTriggerValid = _jerkEngine.IsTriggered;
                        break;
                        
                    case TriggerMode.Permutation_Entropy:
                        isTriggerValid = _entropyEngine.IsSafe;
                        break;
                        
                    case TriggerMode.Hybrid_Jerk_Entropy:
                        isTriggerValid = _jerkEngine.IsTriggered && _entropyEngine.IsSafe;
                        break;
                }
                
                if (isTriggerValid)
                {
                    _logger.Info($"ğŸ”¥ TRIGGER CONFIRMED - {SelectedTrigger}");
                    
                    ExecuteTrade(_pendingSignal.Value, "Trigger Confirmed");
                    _tradeTaken = true;
                    _fractalPeakDetected = false;
                    _pendingSignal = null;
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in CheckTriggerExecution", ex);
            }
        }
        
        private double NormalizeVolume(double targetVolume)
        {
            if (targetVolume <= 0) return 0;

            double step = Symbol.VolumeInUnitsStep;
            double min = Symbol.VolumeInUnitsMin;
            double max = Symbol.VolumeInUnitsMax;

            double normalized = Math.Round(targetVolume / step) * step;

            if (normalized < min) return 0;
            if (normalized > max) return max;

            return normalized;
        }
        
        private void ExecuteTrade(TradeType direction, string scenario)
        {
            try
            {
                double price = direction == TradeType.Buy ? Symbol.Ask : Symbol.Bid;
                double pZero = direction == TradeType.Buy ? _pZeroBuy : _pZeroSell;
                double stretch = Math.Abs(price - pZero);
                
                double stopLossPrice;
                if (direction == TradeType.Buy)
                {
                    stopLossPrice = _pZeroSell - Symbol.PipSize;
                }
                else
                {
                    stopLossPrice = _pZeroBuy + Symbol.PipSize;
                }
                
                double slDist = Math.Abs(price - stopLossPrice);
                
                double minSL = MinStopLossPips * Symbol.PipSize;
                slDist = Math.Max(slDist, minSL);
                
                double slPips = slDist / Symbol.PipSize;
                double risk = Account.Balance * (RiskPercent / 100.0);
                double volume = risk / (slPips * Symbol.PipValue);
                
                volume = NormalizeVolume(volume);
                
                if (volume < Symbol.VolumeInUnitsMin)
                {
                    _logger.Warning($"Volume too small: {volume}");
                    return;
                }
                
                double tp1 = pZero;
                double tp2 = direction == TradeType.Buy ? 
                    price + (stretch * BallisticMultiplier) : 
                    price - (stretch * BallisticMultiplier);
                
                var result = ExecuteMarketOrder(direction, SymbolName, volume, 
                    MagicNumber.ToString(), null, null);
                
                if (result != null && result.IsSuccessful && result.Position != null)
                {
                    ModifyPositionSafe(result.Position, stopLossPrice, null);
                    
                    lock (_tradesLock)
                    {
                        _activeTrades[result.Position.Id] = new TradeContext
                        {
                            PositionId = result.Position.Id,
                            EntryPrice = price,
                            PZero = pZero,
                            Stretch = stretch,
                            TP1 = tp1,
                            TP2 = tp2,
                            TP1Hit = false,
                            TP2Hit = false,
                            TrailingActive = false,
                            EntryBarIndex = Bars.Count - 1,
                            EntryTrendState = (int)_trendState[Bars.Count - 1],
                            Direction = direction,
                            EntryTime = Server.Time,
                            OriginalVolume = volume
                        };
                    }
                    
                    _chaosActive = false;
                    _fractalPeakDetected = false;
                    
                    _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    _logger.Info($"ğŸš€ TRADE EXECUTED - {scenario}");
                    _logger.Info($"Position: {result.Position.Id}");
                    _logger.Info($"Direction: {direction}");
                    _logger.Info($"Entry: {price:F5}");
                    _logger.Info($"Volume: {volume / 1000:F2} lots");
                    _logger.Info($"Stop: {slPips:F1} pips (Min: {MinStopLossPips})");
                    _logger.Info($"Risk: ${risk:F2}");
                    _logger.Info($"TP1: {tp1:F5}");
                    _logger.Info($"TP2: {tp2:F5}");
                    _logger.Info($"P-Zero: {pZero:F5}");
                    _logger.Info($"Stretch: {stretch / Symbol.PipSize:F1} pips");
                    _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                }
                else
                {
                    _logger.Error($"âŒ Trade failed: {result?.Error}");
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in ExecuteTrade", ex);
            }
        }
        
        private void UpdateToxicity()
        {
            if (!EnableToxicityGuard)
            {
                _marketSafe = true;
                _isWarmedUp = true;
                return;
            }
            
            try
            {
                double bid = Symbol.Bid;
                double ask = Symbol.Ask;
                if (bid <= 0 || ask <= 0) return;
                
                double currentSpread = (ask - bid) / Symbol.PipSize;
                
                _minuteSpreads.Add(currentSpread);
                
                int currentMinute = Server.Time.Minute;
                if (currentMinute != _lastProcessedMinute)
                {
                    if (_minuteSpreads.Count > 0)
                    {
                        _minuteSpreads.Sort();
                        double minuteMedian = _minuteSpreads[_minuteSpreads.Count / 2];
                        
                        _rollingBaseline.Enqueue(minuteMedian);
                        
                        if (_rollingBaseline.Count > WarmupMinutes)
                        {
                            _rollingBaseline.Dequeue();
                            
                            if (!_isWarmedUp)
                            {
                                _isWarmedUp = true;
                                var tempBase = _rollingBaseline.ToArray();
                                Array.Sort(tempBase);
                                _baselineSpread = tempBase[tempBase.Length / 2];
                                
                                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                                _logger.Info($"âœ… TOXICITY GUARD READY");
                                _logger.Info($"ğŸ“Š Baseline Spread: {_baselineSpread:F1} pips");
                                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                            }
                        }
                        
                        if (_rollingBaseline.Count > 0)
                        {
                            var allBaselines = _rollingBaseline.ToArray();
                            Array.Sort(allBaselines);
                            _baselineSpread = allBaselines[allBaselines.Length / 2];
                        }
                    }
                    
                    _minuteSpreads.Clear();
                    _lastProcessedMinute = currentMinute;
                }
                
                if (!_isWarmedUp)
                {
                    _marketSafe = false;
                    _toxicityScore = 0;
                    return;
                }
                
                double safeBaseline = _baselineSpread > 0 ? _baselineSpread : 1.0;
                _toxicityScore = currentSpread / safeBaseline;
                _marketSafe = _toxicityScore < ToxicityThreshold;
            }
            catch (Exception ex)
            {
                _logger.Error("Error in UpdateToxicity", ex);
                _marketSafe = false;
            }
        }
        
        private void ManagePositions()
        {
            try
            {
                List<int> toRemove = new List<int>();
                List<TradeContext> contexts;
                
                lock (_tradesLock)
                {
                    contexts = _activeTrades.Values.ToList();
                }
                
                foreach (var ctx in contexts)
                {
                    var pos = Positions.FirstOrDefault(p => p.Id == ctx.PositionId);
                    
                    if (pos == null)
                    {
                        toRemove.Add(ctx.PositionId);
                        continue;
                    }
                    
                    double price = pos.TradeType == TradeType.Buy ? Symbol.Bid : Symbol.Ask;
                    int idx = Bars.Count - 1;
                    int bars = idx - ctx.EntryBarIndex;
                    
                    if (EnableTrendReversalExit && idx >= 0 && idx < _trendState.Count)
                    {
                        int currTrend = (int)_trendState[idx];
                        
                        if (ctx.EntryTrendState != 0 && currTrend != 0 && 
                            ctx.EntryTrendState != currTrend)
                        {
                            _logger.Info($"ğŸ”„ TREND REVERSAL - Pos {pos.Id}");
                            ClosePositionSafe(pos);
                            toRemove.Add(ctx.PositionId);
                            _perfMonitor?.RecordTrade(pos.NetProfit);
                            continue;
                        }
                    }
                    
                    if (EnableTimeStops)
                    {
                        if (!ctx.TP1Hit && bars > TimeStop1Bars)
                        {
                            _logger.Info($"â° TIME STOP 1 - Pos {pos.Id}");
                            ClosePositionSafe(pos);
                            toRemove.Add(ctx.PositionId);
                            _perfMonitor?.RecordTrade(pos.NetProfit);
                            continue;
                        }
                        
                        if (ctx.TP1Hit && !ctx.TP2Hit && bars > TimeStop2Bars)
                        {
                            _logger.Info($"â° TIME STOP 2 - Pos {pos.Id}");
                            ClosePositionSafe(pos);
                            toRemove.Add(ctx.PositionId);
                            _perfMonitor?.RecordTrade(pos.NetProfit);
                            continue;
                        }
                    }
                    
                    double currentFD = _fractalDimension.LastValue;
                    
                    if (!ctx.TP1Hit)
                    {
                        bool tp1Hit = pos.TradeType == TradeType.Buy ? 
                            price >= ctx.TP1 : price <= ctx.TP1;
                        
                        if (tp1Hit)
                        {
                            ModifyPositionSafe(pos, ctx.EntryPrice, null);
                            ctx.TP1Hit = true;
                            ctx.TrailingActive = true;
                            _logger.Info($"âœ… TP1 HIT - Pos {pos.Id}. Breakeven set.");
                            
                            if (SmartExitEnabled)
                            {
                                double closePercent = currentFD < ChaosThresholdFD ? TP1StablePercent : TP1ChaosPercent;
                                double rawCloseVol = pos.VolumeInUnits * (closePercent / 100.0);
                                double closeVol = NormalizeVolume(rawCloseVol);
                                
                                double remainingVol = pos.VolumeInUnits - closeVol;
                                if (closeVol >= Symbol.VolumeInUnitsMin && remainingVol >= Symbol.VolumeInUnitsMin)
                                {
                                    var res = ClosePositionSafe(pos, closeVol);
                                    
                                    if (res != null && res.IsSuccessful)
                                    {
                                        _logger.Info($"Partial close at TP1: {closeVol / 1000:F2} lots ({closePercent}%)");
                                    }
                                }
                                else
                                {
                                    _logger.Info($"Skipped partial close at TP1: Invalid volume split.");
                                }
                            }
                        }
                    }
                    
                    if (ctx.TP1Hit && !ctx.TP2Hit)
                    {
                        bool tp2Hit = pos.TradeType == TradeType.Buy ? 
                            price >= ctx.TP2 : price <= ctx.TP2;
                        
                        if (tp2Hit)
                        {
                            if (SmartExitEnabled)
                            {
                                if (currentFD >= ChaosThresholdFD)
                                {
                                    _logger.Info($"ğŸ¯ TP2 HIT (Chaos) - Closing all - Pos {pos.Id}");
                                    ClosePositionSafe(pos);
                                    toRemove.Add(ctx.PositionId);
                                    ctx.TP2Hit = true;
                                    _perfMonitor?.RecordTrade(pos.NetProfit);
                                    continue;
                                }
                                else
                                {
                                    double closePercent = TP2StablePercent;
                                    double rawCloseVol = ctx.OriginalVolume * (closePercent / 100.0);
                                    double closeVol = NormalizeVolume(rawCloseVol);
                                    
                                    double remainingVol = pos.VolumeInUnits - closeVol;
                                    if (closeVol >= Symbol.VolumeInUnitsMin && remainingVol >= Symbol.VolumeInUnitsMin)
                                    {
                                        var res = ClosePositionSafe(pos, closeVol);
                                        
                                        if (res != null && res.IsSuccessful)
                                        {
                                            _logger.Info($"Partial close at TP2: {closeVol / 1000:F2} lots ({closePercent}%)");
                                        }
                                    }
                                    else
                                    {
                                        _logger.Info($"Skipped partial close at TP2: Invalid volume split.");
                                    }
                                }
                            }
                            else
                            {
                                _logger.Info($"ğŸ¯ TP2 HIT - Pos {pos.Id}");
                                ClosePositionSafe(pos);
                                toRemove.Add(ctx.PositionId);
                                ctx.TP2Hit = true;
                                _perfMonitor?.RecordTrade(pos.NetProfit);
                                continue;
                            }
                        }
                    }
                    
                    if (ctx.TrailingActive)
                    {
                        if (idx >= 2 && !double.IsNaN(_trailingSmooth[idx]))
                        {
                            double smootherValue = _trailingSmooth[idx];
                            double distance = Math.Abs(price - smootherValue);
                            double offset = distance * (TrailingOffsetPercent / 100.0);
                            
                            double trailPrice;
                            if (pos.TradeType == TradeType.Buy)
                            {
                                trailPrice = smootherValue - offset;
                            }
                            else
                            {
                                trailPrice = smootherValue + offset;
                            }
                            
                            bool isCorrectSide = pos.TradeType == TradeType.Buy ? price > smootherValue : price < smootherValue;
                            bool isRatchet = pos.TradeType == TradeType.Buy ? trailPrice > (pos.StopLoss ?? ctx.EntryPrice) : trailPrice < (pos.StopLoss ?? ctx.EntryPrice);
                            bool isAboveEntry = pos.TradeType == TradeType.Buy ? trailPrice > ctx.EntryPrice : trailPrice < ctx.EntryPrice;
                            
                            if (isCorrectSide && isRatchet && isAboveEntry)
                            {
                                ModifyPositionSafe(pos, trailPrice, pos.TakeProfit);
                            }
                        }
                    }
                }
                
                if (toRemove.Count > 0)
                {
                    lock (_tradesLock)
                    {
                        foreach (var id in toRemove)
                            _activeTrades.Remove(id);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.Error("Error in ManagePositions", ex);
            }
        }
        
        private TradeResult ClosePositionSafe(Position pos, double? volume = null)
        {
            try
            {
                if (pos == null)
                    return null;
                
                var result = volume.HasValue ? 
                    ClosePosition(pos, volume.Value) : 
                    ClosePosition(pos);
                
                if (result != null && result.IsSuccessful)
                    _logger.Info($"âœ… Closed {pos.Id}");
                else
                    _logger.Error($"âŒ Failed to close {pos.Id}");
                
                return result;
            }
            catch (Exception ex)
            {
                _logger.Error($"Exception closing {pos?.Id}", ex);
                return null;
            }
        }
        
        private TradeResult ModifyPositionSafe(Position pos, double? sl, double? tp)
        {
            try
            {
                if (pos == null)
                    return null;
                
                return ModifyPosition(pos, sl, tp);
            }
            catch (Exception ex)
            {
                _logger.Error($"Exception modifying {pos?.Id}", ex);
                return null;
            }
        }
        
        private void OnPositionClosed(PositionClosedEventArgs args)
        {
            try
            {
                var pos = args.Position;
                
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info("ğŸ“Š POSITION CLOSED");
                _logger.Info($"ID: {pos.Id}");
                _logger.Info($"Direction: {pos.TradeType}");
                _logger.Info($"Entry: {pos.EntryPrice:F5}");
                _logger.Info($"P&L: ${pos.NetProfit:F2}");
                _logger.Info($"Pips: {pos.Pips:F1}");
                _logger.Info($"Reason: {args.Reason}");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                lock (_tradesLock)
                {
                    _activeTrades.Remove(pos.Id);
                }
                
                _perfMonitor?.RecordTrade(pos.NetProfit);
            }
            catch (Exception ex)
            {
                _logger.Error("Error in OnPositionClosed", ex);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DASHBOARD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        private void InitializeDashboard()
        {
            if (!ShowDashboard) return;
            
            _contentPanel = new StackPanel
            {
                Orientation = Orientation.Vertical,
                Margin = 10,
                Width = 250
            };
            
            _contentPanel.AddChild(CreateHeader("âš¡ HydroDynamic v10.0"));
            
            _contentPanel.AddChild(CreateRow("Guard:", out _valGuard));
            _contentPanel.AddChild(CreateRow("Trend:", out _valTrend));
            _contentPanel.AddChild(CreateRow("State:", out _valState));
            _contentPanel.AddChild(CreateRow("P-Zero Buy:", out _valZeroBuy));
            _contentPanel.AddChild(CreateRow("P-Zero Sell:", out _valZeroSell));
            _contentPanel.AddChild(CreateRow("Trigger:", out _valTrigger));
            _contentPanel.AddChild(CreateRow("Last PnL:", out _valTrades));
            
            _mainBorder = new Border
            {
                BackgroundColor = Color.FromArgb(200, 0, 0, 0),
                BorderColor = Color.Gold,
                BorderThickness = 2,
                CornerRadius = 5,
                Child = _contentPanel,
                VerticalAlignment = VerticalAlignment.Top,
                HorizontalAlignment = HorizontalAlignment.Left,
                Margin = 20
            };
            
            Chart.AddControl(_mainBorder);
        }
        
        private StackPanel CreateRow(string title, out TextBlock valueBlock)
        {
            var rowPanel = new StackPanel 
            { 
                Orientation = Orientation.Horizontal, 
                Margin = new Thickness(0, 5, 0, 0) 
            };
            
            var lbl = new TextBlock
            {
                Text = title,
                ForegroundColor = _colTitle,
                FontWeight = FontWeight.Bold,
                Width = 100
            };
            
            valueBlock = new TextBlock
            {
                Text = "...",
                ForegroundColor = _colNeutral,
                HorizontalAlignment = HorizontalAlignment.Right
            };
            
            rowPanel.AddChild(lbl);
            rowPanel.AddChild(valueBlock);
            return rowPanel;
        }
        
        private TextBlock CreateHeader(string text)
        {
            return new TextBlock
            {
                Text = text,
                ForegroundColor = Color.Cyan,
                HorizontalAlignment = HorizontalAlignment.Center,
                FontWeight = FontWeight.ExtraBold,
                Margin = new Thickness(0, 0, 0, 10),
                FontSize = 14
            };
        }
        
        private void UpdateDashboard()
        {
            if (!ShowDashboard || _mainBorder == null) return;
            
            double currentSpread = (Symbol.Ask - Symbol.Bid) / Symbol.PipSize;
            
            if (EnableToxicityGuard)
            {
                _valGuard.Text = $"{currentSpread:F1} / {(_baselineSpread > 0 ? _baselineSpread.ToString("F1") : "-")}";
                _valGuard.ForegroundColor = _marketSafe ? _colPositive : _colNegative;
            }
            else
            {
                _valGuard.Text = "OFF (Always Safe)";
                _valGuard.ForegroundColor = _colNeutral;
            }
            
            int tState = (int)_trendState.Last(0);
            if (tState == 1) 
            {
                _valTrend.Text = "UP â†—";
                _valTrend.ForegroundColor = _colPositive;
            }
            else if (tState == -1)
            {
                _valTrend.Text = "DOWN â†˜";
                _valTrend.ForegroundColor = _colNegative;
            }
            else
            {
                _valTrend.Text = "RANGE â†”";
                _valTrend.ForegroundColor = _colNeutral;
            }
            
            if (_chaosActive)
            {
                if (_fractalPeakDetected)
                {
                    _valState.Text = "PEAK FOUND âœ…";
                    _valState.ForegroundColor = _colPositive;
                }
                else
                {
                    _valState.Text = "CHAOS âš ï¸";
                    _valState.ForegroundColor = _colWarning;
                }
            }
            else
            {
                _valState.Text = "NORMAL";
                _valState.ForegroundColor = _colNeutral;
            }
            
            _valZeroBuy.Text = _pZeroBuy > 0 ? _pZeroBuy.ToString("F5") : "---";
            _valZeroSell.Text = _pZeroSell > 0 ? _pZeroSell.ToString("F5") : "---";
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Smart Trigger Display (MODULAR)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            switch (SelectedTrigger)
            {
                case TriggerMode.TTL_Legacy:
                    if (_legacyTip != null)
                    {
                        double zScore = _legacyTip.ZScore;
                        _valTrigger.Text = $"TTL: {zScore:F2}";
                        _valTrigger.ForegroundColor = _legacyTip.IsTriggered ? _colPositive : Color.Gray;
                    }
                    break;
                    
                case TriggerMode.Kinematic_Jerk:
                    if (_jerkEngine != null)
                    {
                        double jerkVal = _jerkEngine.Value;
                        _valTrigger.Text = $"JK: {jerkVal:F2}";
                        _valTrigger.ForegroundColor = _jerkEngine.IsTriggered ? _colPositive : Color.Gray;
                    }
                    break;
                    
                case TriggerMode.Permutation_Entropy:
                    if (_entropyEngine != null)
                    {
                        double peVal = _entropyEngine.Value;
                        _valTrigger.Text = $"PE: {peVal:F2}";
                        _valTrigger.ForegroundColor = _entropyEngine.IsSafe ? _colPositive : _colWarning;
                    }
                    break;
                    
                case TriggerMode.Hybrid_Jerk_Entropy:
                    if (_jerkEngine != null && _entropyEngine != null)
                    {
                        double jVal = _jerkEngine.Value;
                        double pVal = _entropyEngine.Value;
                        _valTrigger.Text = $"J:{jVal:F1}|P:{pVal:F2}";
                        
                        bool bothValid = _jerkEngine.IsTriggered && _entropyEngine.IsSafe;
                        _valTrigger.ForegroundColor = bothValid ? _colPositive : Color.Gray;
                    }
                    break;
            }
            
            var lastPos = History.FindLast(MagicNumber.ToString());
            if (lastPos != null)
            {
                _valTrades.Text = $"{lastPos.NetProfit:F2}$";
                _valTrades.ForegroundColor = lastPos.NetProfit >= 0 ? _colPositive : _colNegative;
            }
            else
            {
                _valTrades.Text = "No Trades";
            }
        }
        
        private void DrawPZeroMarkers()
        {
            if (!ShowDashboard) return;
            
            int index = Bars.Count - 1;
            
            if (_pZeroBuy > 0)
            {
                string objBuy = "PZero_Buy";
                Chart.DrawTrendLine(objBuy, index, _pZeroBuy, index + 5, _pZeroBuy, Color.Lime, 2, LineStyle.Dots);
                Chart.DrawText(objBuy + "_txt", " Buy", index + 5, _pZeroBuy, Color.Lime);
            }
            
            if (_pZeroSell > 0)
            {
                string objSell = "PZero_Sell";
                Chart.DrawTrendLine(objSell, index, _pZeroSell, index + 5, _pZeroSell, Color.Red, 2, LineStyle.Dots);
                Chart.DrawText(objSell + "_txt", " Sell", index + 5, _pZeroSell, Color.Red);
            }
        }
        
        private void StopDashboard()
        {
            if (_mainBorder != null)
                Chart.RemoveControl(_mainBorder);
            
            Chart.RemoveObject("PZero_Buy");
            Chart.RemoveObject("PZero_Buy_txt");
            Chart.RemoveObject("PZero_Sell");
            Chart.RemoveObject("PZero_Sell_txt");
        }
        
        protected override void OnStop()
        {
            try
            {
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info("â¹ï¸  STOPPING BOT");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                if (_perfMonitor != null && ShowPerformanceStats)
                {
                    _logger.Info(_perfMonitor.GetReport());
                }
                
                lock (_tradesLock)
                {
                    _logger.Info($"Active Trades: {_activeTrades.Count}");
                    
                    if (_activeTrades.Count > 0)
                    {
                        _logger.Warning("âš ï¸ Open positions!");
                        foreach (var ctx in _activeTrades.Values)
                            _logger.Info($"  - {ctx}");
                    }
                }
                
                _logger.Info($"Market Status:");
                _logger.Info($"  P-Zero Buy: {_pZeroBuy:F5}");
                _logger.Info($"  P-Zero Sell: {_pZeroSell:F5}");
                _logger.Info($"  Chaos Active: {_chaosActive}");
                _logger.Info($"  Peak Detected: {_fractalPeakDetected}");
                _logger.Info($"  Market Safe: {_marketSafe}");
                _logger.Info($"  Toxicity: {_toxicityScore:F2}");
                
                _logger.Info(_logger.GetSummary());
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                _logger.Info("âœ… Bot stopped!");
                _logger.Info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                
                Positions.Closed -= OnPositionClosed;
                StopDashboard();
            }
            catch (Exception ex)
            {
                Print($"âŒ Error in OnStop: {ex.Message}");
            }
        }
    }
}
